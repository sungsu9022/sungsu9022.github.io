<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.3.3" /><meta property="og:title" content="[kubernetes-in-action] 1. 쿠버네티스 소개" /><meta name="author" content="sungsu park" /><meta property="og:locale" content="en" /><meta name="description" content="1. 쿠버네티스 소개 쿠버네티스 등장 배경 거대한 모놀리스 레거시 애플리케이션은 점차 마이크로 서비스라는 독립적으로 실행되는 더 작은 구성 요소로 세분화되고 있다. 마이크로 서비스는 서루 분리돼 있기 떄문에 개별적으로 개발, 배포, 업데이트, 확장할 수 있다. 이로써 오늘날 급변하는 비즈니스 요구사항을 충족시킬 만큼 신속하게 자주 구성 요소를 변경할 수 있게 되었다. 하지만 배포 가능한 구성 요소 수가 많아지고 데이터 센터의 규모가 커지면서 전체 시스템을 원활하게 구성, 관리 유지하는 일이 점점 더 어려워졌다. 이런 구성 요소의 서버 배포를 자동으로 스케줄링하고 구성, 관리, 장애 처리를 포함하는 자동화가 필요한데, 이것이 바로 “쿠버네티스”가 등장한 이유이다." /><meta property="og:description" content="1. 쿠버네티스 소개 쿠버네티스 등장 배경 거대한 모놀리스 레거시 애플리케이션은 점차 마이크로 서비스라는 독립적으로 실행되는 더 작은 구성 요소로 세분화되고 있다. 마이크로 서비스는 서루 분리돼 있기 떄문에 개별적으로 개발, 배포, 업데이트, 확장할 수 있다. 이로써 오늘날 급변하는 비즈니스 요구사항을 충족시킬 만큼 신속하게 자주 구성 요소를 변경할 수 있게 되었다. 하지만 배포 가능한 구성 요소 수가 많아지고 데이터 센터의 규모가 커지면서 전체 시스템을 원활하게 구성, 관리 유지하는 일이 점점 더 어려워졌다. 이런 구성 요소의 서버 배포를 자동으로 스케줄링하고 구성, 관리, 장애 처리를 포함하는 자동화가 필요한데, 이것이 바로 “쿠버네티스”가 등장한 이유이다." /><link rel="canonical" href="https://sungsu9022.github.io/posts/devlog-platform-kubernetes-in-action1/" /><meta property="og:url" content="https://sungsu9022.github.io/posts/devlog-platform-kubernetes-in-action1/" /><meta property="og:site_name" content="Sungsu’s Tech Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-08-01T17:34:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[kubernetes-in-action] 1. 쿠버네티스 소개" /><meta name="twitter:site" content="@sungsu9022dev" /><meta name="twitter:creator" content="@sungsu park" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"sungsu park"},"dateModified":"2020-08-01T17:34:00+09:00","datePublished":"2020-08-01T17:34:00+09:00","description":"1. 쿠버네티스 소개 쿠버네티스 등장 배경 거대한 모놀리스 레거시 애플리케이션은 점차 마이크로 서비스라는 독립적으로 실행되는 더 작은 구성 요소로 세분화되고 있다. 마이크로 서비스는 서루 분리돼 있기 떄문에 개별적으로 개발, 배포, 업데이트, 확장할 수 있다. 이로써 오늘날 급변하는 비즈니스 요구사항을 충족시킬 만큼 신속하게 자주 구성 요소를 변경할 수 있게 되었다. 하지만 배포 가능한 구성 요소 수가 많아지고 데이터 센터의 규모가 커지면서 전체 시스템을 원활하게 구성, 관리 유지하는 일이 점점 더 어려워졌다. 이런 구성 요소의 서버 배포를 자동으로 스케줄링하고 구성, 관리, 장애 처리를 포함하는 자동화가 필요한데, 이것이 바로 “쿠버네티스”가 등장한 이유이다.","headline":"[kubernetes-in-action] 1. 쿠버네티스 소개","mainEntityOfPage":{"@type":"WebPage","@id":"https://sungsu9022.github.io/posts/devlog-platform-kubernetes-in-action1/"},"url":"https://sungsu9022.github.io/posts/devlog-platform-kubernetes-in-action1/"}</script><title>[kubernetes-in-action] 1. 쿠버네티스 소개 | Sungsu's Tech Blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Sungsu's Tech Blog"><meta name="application-name" content="Sungsu's Tech Blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/personal/sunny.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">Sungsu's Tech Blog</a></div><div class="site-subtitle font-italic">Java/Kotlin Spring, Back-end</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/sungsu9022" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/sungsu9022dev" aria-label="twitter" target="_blank" rel="noopener noreferrer"> <i class="fab fa-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['sungsu9022','naver.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[kubernetes-in-action] 1. 쿠버네티스 소개</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>[kubernetes-in-action] 1. 쿠버네티스 소개</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1596270840" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Aug 1, 2020 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href=""></a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="7624 words"> <em>42 min</em> read</span></div></div></div><div class="post-content"><h1 id="1-쿠버네티스-소개">1. 쿠버네티스 소개</h1><h2 id="쿠버네티스-등장-배경"><span class="mr-2">쿠버네티스 등장 배경</span><a href="#쿠버네티스-등장-배경" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><blockquote><p>거대한 모놀리스 레거시 애플리케이션은 점차 마이크로 서비스라는 독립적으로 실행되는 더 작은 구성 요소로 세분화되고 있다. 마이크로 서비스는 서루 분리돼 있기 떄문에 개별적으로 개발, 배포, 업데이트, 확장할 수 있다. 이로써 오늘날 급변하는 비즈니스 요구사항을 충족시킬 만큼 신속하게 자주 구성 요소를 변경할 수 있게 되었다. 하지만 배포 가능한 구성 요소 수가 많아지고 데이터 센터의 규모가 커지면서 전체 시스템을 원활하게 구성, 관리 유지하는 일이 점점 더 어려워졌다. 이런 구성 요소의 서버 배포를 자동으로 스케줄링하고 구성, 관리, 장애 처리를 포함하는 자동화가 필요한데, 이것이 바로 “쿠버네티스”가 등장한 이유이다.</p></blockquote><h2 id="쿠버네티스-어원"><span class="mr-2">쿠버네티스 어원</span><a href="#쿠버네티스-어원" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><blockquote><p>쿠버네티스는 조종사, 조타수(선박의 핸들을 잡고 있는 사람)를 뜻하는 그리스어</p></blockquote><h2 id="쿠버네티스"><span class="mr-2">쿠버네티스</span><a href="#쿠버네티스" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><blockquote><p>쿠버네티스는 하드웨어 인프라를 추상화하고 데이터 센터 전체를 하나의 거대한 컴퓨팅 리소스로 제공한다. 실제 세세한 서버 정보를 알 필요 없이 애플리케이션 구성요소를 배포하고 실행할 수 있다. 쿠버네티스를 이용하여 하드웨어에서 실행되는 수만 개의 애플리케이션을 일일이 알 필요가 없게 되었다.</p></blockquote><h2 id="11-쿠버네티스와-같은-시스템이-필요한-이유"><span class="mr-2">1.1 쿠버네티스와 같은 시스템이 필요한 이유</span><a href="#11-쿠버네티스와-같은-시스템이-필요한-이유" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="111-모놀리스-애플리케이션에서-마이크로-서비스-전환"><span class="mr-2">1.1.1 모놀리스 애플리케이션에서 마이크로 서비스 전환</span><a href="#111-모놀리스-애플리케이션에서-마이크로-서비스-전환" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>모놀리스 애플리케이션은 앱을 실행하는데 충분한 리소스를 제공할 수 있는 소수의 강력한 서버가 필요하다.<li>여기서 시스템의 증가하는 부하를 처리할수 있는 방법은 Scale up과 Scale out이 있는데..</ul><h4 id="수직-확장scale-up"><span class="mr-2">수직 확장(scale up)</span><a href="#수직-확장scale-up" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>시스템의 증가하는 부하를 처리하려고 하면 CPU, 메모리 등을 추가해 서버를 수직 확장(scale up)하거나 서버를 추가하는 방법<li>비교적 비용이 많이 들고 실제 확장에 한계가 있음.</ul><h4 id="수평-확장scale-out"><span class="mr-2">수평 확장(scale out)</span><a href="#수평-확장scale-out" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>애플리케이션의 복사본을 실행해 전체 시스템을 수평 확장(scale out)하는 방법<li>상대적으로 저렴하지만, 애플리케이션 코드의 큰 변경이 필요할 수도 있고, 항상 가능하지 않음.(예를 들면 RDBMS 같은 경우에 scale out은 불가하고, HA 구성을 위해서는 다른 방식으로 사용)</ul><h4 id="마이크로서비스로-애플리케이션-분할"><span class="mr-2">마이크로서비스로 애플리케이션 분할</span><a href="#마이크로서비스로-애플리케이션-분할" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>하나의 포르세스였던것을 독립적인 프로세스로 나누어서 실행하고, 잘 정의된 API로 상호 통신한다.(Resetful API를 제공하는 HTTP 또는 AMQP와 같은 비동기 프로토콜)</ul><h4 id="마이크로서비스-확장"><span class="mr-2">마이크로서비스 확장</span><a href="#마이크로서비스-확장" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>전체 시스템을 함께 확장해야 하는 모놀리스 시스템과 달리 마이크로 서비스 확장은 서비스별로 수행되므로 리소스가 더 필요한 서비스만 별도로 확장할 수 있으며 다른 서비스는 그대로 둬도 된다.</ul><h4 id="마이크로서비스-배포"><span class="mr-2">마이크로서비스 배포</span><a href="#마이크로서비스-배포" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>마이크로서비스에도 단점이 있는데, 구성요소가 많아지면 배포 조합의 수 뿐만 아니라 구성 요소 간의 상호 종속성 수가 훨씬 더 많아지므로 배포 관련 결정이 점점 더 어려워질 수 있음.<li>마이크로서비스는 여러 개가 서로 함께 작업을 수행하므로 서로를 찾아 통신해야 하는데, 서비스 수가 증가함에 따라 특히 서버 장애 상황에서 해야 할 일을 생각해봤을 때 전체 아키텍쳐 구성의 어려움과 오류 발생 가능성이 높아진다.<li>또한 실행 호출을 디버깅하고 추적하기 어려운 단점이 있을수 있는데 Zipkin과 같은 분산 추적 시스템으로 해결은 가능함.</ul><h4 id="환경-요구-사항의-다양성"><span class="mr-2">환경 요구 사항의 다양성</span><a href="#환경-요구-사항의-다양성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>애플리케이션이 서로 다른 버전의 동일한 라이브러리를 필요로 하는 경우 애플리케이션 구성 요소간 종속성의 차이는 불가피하다.<li>동일한 호스트에 배포해야 하는 구성 요소 수가 많을수록 모든 요구사항을 충족시키려 모든 종속성을 관리하기가 더 어려워진다.</ul><p><a href="https://user-images.githubusercontent.com/6982740/89101745-c287e180-d43d-11ea-8d26-891ef455f357.png" class="popup img-link "><img width="541" alt="스크린샷 2020-08-01 오후 9 27 02" data-src="https://user-images.githubusercontent.com/6982740/89101745-c287e180-d43d-11ea-8d26-891ef455f357.png" class="lazyload" data-proofer-ignore></a></p><h3 id="112-애플리케이션에-일관된-환경-제공"><span class="mr-2">1.1.2 애플리케이션에 일관된 환경 제공</span><a href="#112-애플리케이션에-일관된-환경-제공" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>애플리케이션을 실행하는 환경이 다른것은 사실 심각한 문제 중에 하나이다.<li>개발과 프로덕션 환겨 사이의 큰 차이 뿐만 아니라 각 프로덕션 머신간에도 차이가 있다.<li>이런 차이는 하드웨어에서 운영체제, 각 시스템에서 사용 가능한 라이브러리에 이르기까지 다양하다.<li>프로덕션 환경에서만 나타나는 문제를 줄이려면 애플리케이션 개발과 프로덕션이 정확히 동일한 환경에서 실행돼 운영체제, 라이브러리, 시스템 구성, 네트워킹 환경, 기타 모든 것이 동일한 환경을 만들 수 있다면 사실 이상적이다.</ul><h3 id="113-지속적인-배포로-전환--데브옵스와-노옵스"><span class="mr-2">1.1.3 지속적인 배포로 전환 : 데브옵스와 노옵스</span><a href="#113-지속적인-배포로-전환--데브옵스와-노옵스" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>과거 개발 팀의 업무는 애플리케이션을 만들고 이를 배포(CD)하고 관리하며 계속 운영하는 운영팀에 넘기는것(?, 회사마다 다름)이었다고 한다.<li>개발팀이 애플리케이션을 배포하고 관리하는 것이 모두가 낫다고 생각한다.<li>개발자, 품질보증(QA), 운영팀이 전체 프로세스에서 협업해야 하는데 이를 “데브옵스”라고 한다.</ul><h4 id="개발자와-시스템-관리자-각자가-최고로-잘하는-것을-하게-하는것"><span class="mr-2">개발자와 시스템 관리자 각자가 최고로 잘하는 것을 하게 하는것!</span><a href="#개발자와-시스템-관리자-각자가-최고로-잘하는-것을-하게-하는것" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>하드웨어 인프라를 전혀 알지 못하더라도 관리자를 거치지 않고 개발자는 애플리케이션을 직접 배포할 수 있다. 이는 가장 이상적인 방법이며, 노옵스(NoOps)라고 부른다,<li>쿠버네티스를 사용하면 이런것들을 해결할 수 있음.<li>하드웨어를 추상화하고 이를 애플리케이션 배포, 실행을 위한 플랫폼으로 제공함으로써,<ul><li>개발자는 시스템 관리자의 도움 없이도 애플리케이션을 구성, 배포할 수 있으며, 시스템 관리자는 실제 실행되는 애플리케이션을 알 필요 없이 인프라를 유지하고 운영하는 데 집중할 수 있다.</ul></ul><h2 id="12-컨테이너-기술-소개"><span class="mr-2">1.2 컨테이너 기술 소개</span><a href="#12-컨테이너-기술-소개" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><blockquote><p>쿠버네티스는 애플리케이션을 격리하는 기능을 제공하기 위해 리눅스 컨테이너 기술을 사용한다. 쿠버네티스 자체를 깊이 파고들기 전에 먼저 컨테이너의 기본에 익숙해져야 한다. 또한 도커나 rkt(rock-it)과 같은 컨테이너 기술이 어떤 문제를 해결하는지 이해해야 한다.</p></blockquote><h3 id="121-컨테이너-이해"><span class="mr-2">1.2.1 컨테이너 이해</span><a href="#121-컨테이너-이해" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>애플리케이션이 더 작은 수의 커다란 구성요소로만 이뤄진 경우 구성요소에 전용 가상머신을 제공하고 고유한 운영체제 인스턴스를를 제공해 환경을 격리할수 있다.<li>하지만 MSA로 인해 구성요소가 작아지면서 숫자가 많아지기 시작하면 하뒈어 리소스 낭비가 생길 수 있음.<li>일반적으로 각각의 가상머신을 개별적으로 구성하고 관리해야 해서 시스템 관리자의 작업량도 상당히 증가한다.</ul><h4 id="리눅스-컨테이너-기술로-구성-요소-격리"><span class="mr-2">리눅스 컨테이너 기술로 구성 요소 격리</span><a href="#리눅스-컨테이너-기술로-구성-요소-격리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>가상머신을 사용해 각 마이크로서비스의 환경을 격리하는 대신 개발자들은 리눅스 컨테이너 기술로 눈을 돌림<li>컨테이너 기술은 가상머신과 유사하게 서로 격리하지만 오버헤드가 훨씬 적음.<li>컨테이너에서 실행되는 프로세스는 다른 모든 프로세스와 마찬가지로 호스트 운영체제 내에서 실행된다.(가상머신은 별도의 운영체제에서 실행됨)</ul><h4 id="컨테이너와-가상머신-비교"><span class="mr-2">컨테이너와 가상머신 비교</span><a href="#컨테이너와-가상머신-비교" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="컨테이너"><span class="mr-2">컨테이너</span><a href="#컨테이너" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><ul><li>컨테이너는 훨씬더 가벼워서 동일한 하드웨어 스펙으로 더 많은 수의 소프트웨어 구성 요소를 실행할 수 있음.<li>호스트 OS에서 실행되는 하나의 격리된 프로세스일뿐, 앱이 소비하는 리소스만 소비하고 추가 프로세스의 오버헤드가 없음.<li>호스트 OS에서 실행되는 동일한 커널에서 시스템 콜을 사용한다.<li>어떠한 종류의 가상화도 필요없음.<li>각각의 컨테이너가 모두 동일한 커널을 호출함으로 보안 위협이 발생할 수 있다.<li>컨테이너를 실행할때 VM처럼 부팅할 필요가 없고, 즉시 프로세스를 실행시킬 수 있음.</ul><h5 id="가상머신"><span class="mr-2">가상머신</span><a href="#가상머신" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><ul><li>구성 요소 프로세스 뿐만 아니라 시스템 프로세스를 실행해야 하기 때문에 추가 컴퓨팅 리소스가 필요하다.<li>호스트에 가상머신 3개를 실행하면 3개의 완전히 분리된 운영체제가 실행되고 동일한 하드웨어를 공유한다.<li>시스템콜을 하이퍼 바이저를 통해 받아서 수행<li>OS를 필요로 하는 하이퍼바이저 타입이 있고, 호스트 타입을 필요로 하지 않는 타입이 있음.<li>독립적인 커널을 호출하므로 보안 위험이 컨테이너에 비해 적다.</ul><h4 id="컨테이너-격리를-가능하게-하는-매커니즘"><span class="mr-2">컨테이너 격리를 가능하게 하는 매커니즘</span><a href="#컨테이너-격리를-가능하게-하는-매커니즘" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>첫번째는 리눅스 네임스페이스로 각 프로세스가 시스템(파일, 프로세스, 네트워크 인터페이스, ㅎ스트 이름 등)에 대한 독립된 뷰만 볼 수 있도록 하는것<li>두번째는 리눅스 컨트롤 그룹(cgroups)으로 프로세스가 사용할 수 있는 리소스(CPU, 메모리, 네트워크 대역폭 등)의 양을 제한하는 것</ul><h4 id="네임-스페이스의-종류"><span class="mr-2">네임 스페이스의 종류</span><a href="#네임-스페이스의-종류" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>마운트(mnt)<li>프로세스 ID(pid)<li>네트워크(net)<li>프로세스간 통신(ipc)<li>호스트와 도메인 이름(uts - Unix Time Sharing)<li>사용자 ID(user)</ul><h4 id="리눅스-네임스페이스로-프로세스-격리"><span class="mr-2">리눅스 네임스페이스로 프로세스 격리</span><a href="#리눅스-네임스페이스로-프로세스-격리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>여러 종류의 네임스페이스가 있기 때문에 프로세스는 하나의 네임스페이스에만 속하는 것이 아니라 여러 네임스페이스에 속할 수 있다.<li>각 네임스페이스는 특정 리소스 그룹을 격리하는데 사용됨.<ul><li>2개의 서로 다른 UTS 네임스페이스를 프로세스에 각각 지정하면 서로 다른 로컬 호스트 이름을 보게할 수 도 있음.(두 프로세스는 마치 두 개의 다른 시스템에서 실행중인것처럼 보이게 할 수 있음.)</ul><li>각 컨테이너는 고유한 네트워크 네임스페이슬르 사용하므로 각 컨테이너는 고유한 네트워크 인터페이스 세트를 보수 있음.</ul><h4 id="프로세스의-가용-리소스-제한"><span class="mr-2">프로세스의 가용 리소스 제한</span><a href="#프로세스의-가용-리소스-제한" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>프로세스의 리소스 사용을 제한하는 리눅스 커널 기능인 cgroups으로 이뤄진다.</ul><h3 id="122-도커-컨테이너-플랫폼-소개"><span class="mr-2">1.2.2 도커 컨테이너 플랫폼 소개</span><a href="#122-도커-컨테이너-플랫폼-소개" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>도커는 컨테이너를 여러 시스템에 쉽게 이식 가능하게 하는 최초의 컨테이너 시스템<li>앱, 라이브러리, 여러 종속성, 심지어 전체 OS 파일시스템까지도 도커를 실행하는 다른 컴퓨터에 애플리케ㅣ션을 프로비저닝하는 데 사용할 수 있다.<li>도커로 패키징된 앱을 실행하면 함께 제공된 파일 시스템 내용을 정확하게 볼수 있다.<li>앱은 실행중인 서버의 내용은 볼 수 없으므로 서버에 개발 컴퓨터와 다른 설치 라이브러리가 설치돼 있는지는 중요하지 않다.<li>가상머신에 운영체제를 설치하고 그 안에 앱을 설치한 다음 가상 머신 이미지를 배포하고 실행하는 가상머신 이미지를 만드는것과 유사함.<li>도커 기반 컨테이너 이미지와 가상머신 이미지의 큰 차이점은 컨테이너 이미지가 여러 이미지에서 공유되고 재사용될 수 있는 레이러로 구성되어 있다는것<ul><li>동일한 레이러르 포함하는 다른 컨테이너 이미지를 실행할 때 다른 레이어에서 이미 다운로드된 경우 이미지의 특정 레이어만 다운로드 하면됨.</ul></ul><h4 id="도커-개념-이해"><span class="mr-2">도커 개념 이해</span><a href="#도커-개념-이해" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><blockquote><p>도커는 앱을 패키징, 배포, 실행하기 위한 플랫폼 전체 환경과 함꼐 패키지화할 수 있음. 도커를 사용하여 패키지를 중앙 저장소로 전송할 수 있고, 이를 도커를 실행하는 모든 컴퓨터에 전송할 수 있음.</p></blockquote><h5 id="이미지"><span class="mr-2">이미지</span><a href="#이미지" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><ul><li>애플리케션과 해당 환경을 패키지화한 것<li>앱에서 사용할 수 있는 파일시스템과 이미지가 실행될때 실행돼야 하는 실행파일 경로와 같은 메타데이터를 포함한다.</ul><h5 id="레지스트리"><span class="mr-2">레지스트리</span><a href="#레지스트리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><ul><li>도커 이미지를 저장하고 다른 사람이나 컴퓨터 간에해당 이미지를 쉽게 공유할 수 있는 저장소 ( push / pull)</ul><h5 id="컨테이너-1"><span class="mr-2">컨테이너</span><a href="#컨테이너-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><ul><li>실행중인 컨테이너는 도커를 실행하는 호스트에서 실행되는 프로세스이지만 호스트와 호스트에서 실행중인 다른 프로세스와는 완전히 격리돼 있음.<li>리소스 사용이 제한돼 있으므로 할당된 리소스의 양(CPU, RAM 등)만 엑세스하고 사용할 수 있다.</ul><h4 id="도커-이미지의-빌드-및-배포-실행"><span class="mr-2">도커 이미지의 빌드 및 배포, 실행</span><a href="#도커-이미지의-빌드-및-배포-실행" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><a href="https://user-images.githubusercontent.com/6982740/89117192-efd49e00-d4d6-11ea-9bbe-e2b1b727010e.png" class="popup img-link "><img width="718" alt="스크린샷 2020-08-02 오후 3 43 31" data-src="https://user-images.githubusercontent.com/6982740/89117192-efd49e00-d4d6-11ea-9bbe-e2b1b727010e.png" class="lazyload" data-proofer-ignore></a></p><h4 id="가상-머신과-도커-컨테이너-비교"><span class="mr-2">가상 머신과 도커 컨테이너 비교</span><a href="#가상-머신과-도커-컨테이너-비교" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><a href="https://user-images.githubusercontent.com/6982740/89117324-cff1aa00-d4d7-11ea-9293-1ee1543dcb2e.png" class="popup img-link "><img data-src="https://user-images.githubusercontent.com/6982740/89117324-cff1aa00-d4d7-11ea-9293-1ee1543dcb2e.png" alt="스크린샷 2020-08-02 오후 3 49 44" class="lazyload" data-proofer-ignore></a></p><ul><li>가상머신에서 실행될 떄와 두 개의 별도 컨테이너로 실행될 때 앱 A,B가 동일한 바이너리, 라이브러리에 접근할 수 있음.<li>컨테이너는 격리된 자체 파일시스템이 있는데 이떄 같은 파일을 공유할 수 있음.</ul><h4 id="이미지-레이어의-이해"><span class="mr-2">이미지 레이어의 이해</span><a href="#이미지-레이어의-이해" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>모든 도커 이미지는 다른 이미지 위에 빌드되고, 2개의 다른 이미지는 동일한 부모 이미지를 사용할 수 있으므로, 서로 정확히 동일한 레이어가 포함될 수 있음.<li>레이어는 배포를 효율적으로 할 뿐만 아니라 이미지의 스토리지 공간을 줄이는 데에도 도움이 된다.<ul><li>각 레이어는 동일 호스트에서 한번만 저장됨.<li>동일한 기본 레이러를 기반으로 한 2개의 이미지에서 생성한 2개의 컨테이너는 동일한 파일을 읽을 수 있지만, 그중 하나가 해당 파일을 덮어쓰면 다른 컨테이너에서는 그 변경 사항을 바라보지 않는다.<li>파일을 공유하더라도 여전히 서로 격리돼 있는데 이것은 컨테이너 이미지 레이어가 읽기 전용이기 때문<li>컨테이너가 실행될때 이미지 레이어 위에 새로운 쓰기 가능한 레이어가 만들어진다.</ul></ul><h4 id="컨테이너-이미지의-제한적인-이식성-이해"><span class="mr-2">컨테이너 이미지의 제한적인 이식성 이해</span><a href="#컨테이너-이미지의-제한적인-이식성-이해" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>이론적으로 컨테이너 이미지는 도커를 실행하는 모든 리눅스 시스템에서 실행될 수 있지만, 호스트에서 실행되는 모든 컨테이너가 호스트의 리눅스 커널을 사용한다는 사실과 관련해 주의해야 한다.<li>컨테이너화된 앱이 특정 커널 버전이 필요하다면 모든 시스템에서 작동하지 않을수 있음.<li>머신이 다른 버전의 리눅스 커널로 실행되거나 동일한 커널 모듈을 사용할 수 없는 경우에는 앱이 실행될 수 없다.<li>컨테이너는 가상머신에 비해 훨씬 가볍지만 컨테이너 내부에서 실행되는 앱은 일정한 제약이 있따.<li>하드웨어 아키텍처용으로 만들어진 컨테이너화된 앱은 해당 아키텍처 시스템에서만 실행될 수 있다는 점을 분명히 해야 한다.</ul><h3 id="123-도커의-대안으로-rkt-소개"><span class="mr-2">1.2.3 도커의 대안으로 rkt 소개</span><a href="#123-도커의-대안으로-rkt-소개" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>rkt는 현시점 deprecated됨.<li>도커와 마찬가지로 컨테이너를 실행하기 위한 플랫폼<li>2018년 이후로 업데이트 없음.</ul><h2 id="13-쿠버네티스-소개"><span class="mr-2">1.3 쿠버네티스 소개</span><a href="#13-쿠버네티스-소개" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="131-쿠버네티스의-기원"><span class="mr-2">1.3.1 쿠버네티스의 기원</span><a href="#131-쿠버네티스의-기원" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>구글은 보그(Borg, 이후 오메가(Omega)로 바뀐 시스템)라는 내부 시스템을 개발해 애플리케이션 개발자와 시스템 관리자가 수천 개의 애플리케이션과 서비스를 관리하는데 도움을 주었다.<li>개발과 관리를 단순화할 뿐만 아니라 인프라 활용률을 크게 높일 수 있었다.<li>2014년 보그, 오메가, 기타 내부 구글 시스템으로 얻은 경험을 기반으로 하는 오픈소스 시스템인 쿠버네티스를 출시</ul><h3 id="132-넓은-시각으로-쿠버네티스-바라보기"><span class="mr-2">1.3.2 넓은 시각으로 쿠버네티스 바라보기</span><a href="#132-넓은-시각으로-쿠버네티스-바라보기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>쿠버네티스는 컨테이너화된 애플리케이션을 쉽게 배포하고 관리할 수 있게 해주는 소프트웨어 시스템<li>애플리케이션은 컨테이너에서 실행되므로 동일한 서버에서 실행되는 다른 앱에 영향을 미치지 않으며, 이는 동일한 하드웨어에서 완전히 다른 조직의 앱을 실행할때 매우 중요하다.<li>호스팅된 앱을 완전히 격리하면서 하드웨어를 최대한 활용한다.<li>모든 노드가 마치 하나의 거대한 컴퓨터인 것처럼 수천대의 컴퓨터 노드에서 스포트웨어 애플리케이션을 실행할 수 있다.</ul><h4 id="쿠버네티스-핵심-이해"><span class="mr-2">쿠버네티스 핵심 이해</span><a href="#쿠버네티스-핵심-이해" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>시스템은 마스터 노드와 여러 워커 노드로 구성<li>구성요소가 어떤 노드에 배포되든지 개발자나 시스템 관리자에게 중요하지 않다.<li>개발자는 앱 디스크립터를 쿠버네티스 마스터에게 게시하면 쿠버네티스는 해당 앱을 워커 노드 클러스터에 배포한다.</ul><p><a href="https://user-images.githubusercontent.com/6982740/89119118-9a07f200-d4e6-11ea-9e80-b007cc72370c.png" class="popup img-link "><img width="656" alt="스크린샷 2020-08-02 오후 5 35 38" data-src="https://user-images.githubusercontent.com/6982740/89119118-9a07f200-d4e6-11ea-9e80-b007cc72370c.png" class="lazyload" data-proofer-ignore></a></p><h4 id="개발자가-앱-핵심-기능에-집중할-수-있도록-지원"><span class="mr-2">개발자가 앱 핵심 기능에 집중할 수 있도록 지원</span><a href="#개발자가-앱-핵심-기능에-집중할-수-있도록-지원" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>쿠버네티스는 마치 클러스터의 운영체제로 생각할 수 있음.<li>서비스 디스커버리 ,스케일링, 로드밸런싱, 자가 치유, 리더 선출 같은 것들을 포함하여 지원한다.</ul><h4 id="운영-팀이-효과적으로-리소스를-활용할-수-있도록-지원"><span class="mr-2">운영 팀이 효과적으로 리소스를 활용할 수 있도록 지원</span><a href="#운영-팀이-효과적으로-리소스를-활용할-수-있도록-지원" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>각 앱들은 어떤 노드에서 실행되든 상관이 없기 때문에 쿠버네티스는 언제든지 앱을 재배치하고, 조합함으로써 리소스를 수동 스케줄링보다 훨씬 잘 활용할 수 있다.</ul><h3 id="133-쿠버네티스-클러스터-아키텍쳐-이해"><span class="mr-2">1.3.3 쿠버네티스 클러스터 아키텍쳐 이해</span><a href="#133-쿠버네티스-클러스터-아키텍쳐-이해" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>하드웨어 수준에서 쿠버네티스 클러스터는 여러 노드로 구성되며, 2가지 유형으로 나눌 수 있다.<blockquote><p>마스터 노드 : 전체 쿠버네티스 시스템을 제어하고 관리하는 쿠버네티스 컨트롤 플레인을 실행 워커 노드 : 실제 배포되는 컨테이너 애플리케이션을 실행</p></blockquote></ul><p><a href="https://user-images.githubusercontent.com/6982740/89119225-772a0d80-d4e7-11ea-99fd-3dbd04beb866.png" class="popup img-link "><img width="643" alt="스크린샷 2020-08-02 오후 5 41 52" data-src="https://user-images.githubusercontent.com/6982740/89119225-772a0d80-d4e7-11ea-99fd-3dbd04beb866.png" class="lazyload" data-proofer-ignore></a></p><h4 id="컨트롤-플레인control-plane"><span class="mr-2">컨트롤 플레인(Control Plane)</span><a href="#컨트롤-플레인control-plane" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>클러스터를 제어하고 작동시키는 역할<li>하나의 마스터 노드에서 실행하거나, 여러 노드로 분할되고 복제하여 고가용성을 보장할 수 있는 여러 구성 요소로 구성할 수 있다.<li>API서버는 사용자, 컨트롤 플레인 구성 요소와 통신<li>스케줄러는 앱의 배포를 담당(앱의 배포 가능한 각 구성요소를 워크 노드에 할당)<li>컨트롤러 매니저는 구성요소 복제본, 워커 노드 추적, 노드 장애 처리 등과 같은 클러스터단의 기능을 수행<li>Etcd는 클러스터 구성을 지속적으로 저장하는 신뢰할 수 있는 분산 데이터 저장소</ul><h4 id="노드worker-node"><span class="mr-2">노드(Worker Node)</span><a href="#노드worker-node" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>컨테이너화된 애플리케이션을 실행하는 시스템<li>컨테이너 런타임은 도커, rkt 또는 다른 컨테이너 런타임이 될 수 있다.<li>kebelet은 API 서버와 통힌하고 노드의 컨테이너를 관리한다.<li>kebe-proxy(쿠버네티스 서비스 프록시)는 앱 구성요소간 네트워크 트래픽을 로드밸런싱한다.</ul><h3 id="134-쿠버네티스에서-애플리케이션-실행"><span class="mr-2">1.3.4 쿠버네티스에서 애플리케이션 실행</span><a href="#134-쿠버네티스에서-애플리케이션-실행" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>애플리케이션을 하나 이상의 컨테이너 이미지로 패키징하고 해당 이미지를 레지스트리로 푸시한 다음에 쿠버네티스 API 서버에 앱 디스크립션을 게시해야 한다.</ul><h4 id="앱-디스크립션에-포함되는-내용들"><span class="mr-2">앱 디스크립션에 포함되는 내용들</span><a href="#앱-디스크립션에-포함되는-내용들" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>컨테이너 이미지<li>앱 구성요소가 포함된 이미지<li>해당 구성요소가 서로 통신하는 방법<li>동일 서버에 함께 배치되어야 하는 구성 요소<li>실행될 각 구성 요소의 본제본 수<li>내부 또는 외부 클라이언트에 서비스를 제공하는 구성요소<li>하나의 IP주소로 노출해 다른 구성 요소에서 검색가능하게 해야 하는 구성요소 등</ul><h4 id="디스크립션으로--컨테이너를-실행하는-방법-이해"><span class="mr-2">디스크립션으로 컨테이너를 실행하는 방법 이해</span><a href="#디스크립션으로--컨테이너를-실행하는-방법-이해" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>1) API 서버가 앱 디스크립션을 처리할때 스케줄러는 각 컨테이너에 필요한 리소스를 계산하고 각 노드에 할당되지 않은 리소스를 기반으로 사용 가능한 워커 노드에 지정된 컨테이너를 할당한다.<li>2) kebulet은 컨테이너 런타임(도커)에 필요한 컨테이너 이미지를 가져와 컨테이너를 실행하도록 지시한다.</ul><h4 id="실행된-컨테이너-유지"><span class="mr-2">실행된 컨테이너 유지</span><a href="#실행된-컨테이너-유지" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>앱이 실행되면 쿠버네티스는 앱의 배포 상태가 사용자가 제공한 디스크립션과 일치하는지 지속적으로 확인한다.<ul><li>예를 들어 5개의 웹 서버 인스턴스를 실행하도록 지정하면 쿠버네티스는 항상 정확히 5개의 인스턴스를 계속 실행<li>프로세스 중단 등 인스턴스가 제대로 동작하지 않으면 자동으로 다시 시작<li>워커 노드 전체가 종료되거나 하면 이 노드에서 실행중인 모든 컨테이너 노드를 새로 스케줄링하고, 새로 선택한 노드에서 실행한다.</ul></ul><h4 id="복제본-수-스케일링"><span class="mr-2">복제본 수 스케일링</span><a href="#복제본-수-스케일링" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>실행되는 동안 복제본 수를 늘릴지 줄일지 결정할 수 있음.<li>최적의 본제본 수를 결정하는 작업을 쿠버네티스에게 위힘할 수 있다.<li>쿠버네티스는 CPU부하, 메모리 사용량, 초당 요청수 등 실시간 메트릭을 기반으로 복제본 수를 자동으로 조정할 수 있다.</ul><h4 id="이동한-애플리케이션에-접근하기"><span class="mr-2">이동한 애플리케이션에 접근하기</span><a href="#이동한-애플리케이션에-접근하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>쿠버네티스는 클라이언트가 특정 서비르르 제공하는 컨테이너를 쉽게 찾을 수 있도록 동일한 서비스를 제공하는 컨테이너를 알려주면 하나의 고정 IP주소로 모든 컨테이너를 노출하고 해당 주소를 클러스터에서 실행중인 모든 앱에 노출한다.<li>DNS로 서비스 IP를 조회할 수도 있음.<li>kube-proxy는 서비스를 제공하는 모든 컨테이너에서 서비스 연결이 로드밸런싱되도록 한다.<li>이런 매커니즘에 의해서 컨테이너들이 클러스터 내에서 이동하더라도 컨테이너에 항상 연결할 수 있음.</ul><h3 id="135-쿠버네티스-사용의-장점"><span class="mr-2">1.3.5 쿠버네티스 사용의 장점</span><a href="#135-쿠버네티스-사용의-장점" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>시스템 관리자는 앱을 배포하고 실행하기 위해 아무것도 설치할 필요가 없음.<li>개발자는 시스템 관리자의 도움 없이 즉시 앱을 실행할 수 있다.</ul><h4 id="애플리케이션-배포의-단순화"><span class="mr-2">애플리케이션 배포의 단순화</span><a href="#애플리케이션-배포의-단순화" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>개발자는 클러스트를 구성하는 서버에 관해 알 필요가 전혀 없다.<li>모든 노드는 단순히 전체 컴퓨팅 리소스일뿐, 앱에 적절한 시스템 리소를 제공할 수 있는 한 어느 서버에서 실행중인지는 신경쓰지 않아도 된다.<li>특정 앱이 특정 종류의 하드웨어에서 실행해야 하는 경우에도 지원이 가능(예를 들면 SSD를 이용해야 하는 경우)</ul><h4 id="하드웨어-활용도-높이기"><span class="mr-2">하드웨어 활용도 높이기</span><a href="#하드웨어-활용도-높이기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>인프라와 애플리케이션을 분리해서 생ㅇ각할 수 있다.<li>쿠버네티스는 요구사항에 대한 디스크립션과 노드에서 사용 가능한 리소스에 따라 앱을 실행한 가장 적합한 노드를 선택할 수 있다.<li>쿠버네티스는 언제든지 클러스터 간에 앱이 이동할 수 있으모로 수동으로 수행하는것보다 훨씬 더 인프라를 잘 활용할 수 있다.</ul><h4 id="상태-확인과-자가-치유"><span class="mr-2">상태 확인과 자가 치유</span><a href="#상태-확인과-자가-치유" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>서버 장애 발생시 언제든지 클러스터 간에 앱을 이동시킬수 있는 시스템이 갖출수 있다.<li>쿠버네티스는 앱 구성요소와 구동중인 워커 노드를 모니터링하다가 노드 장애 발생시 자동으로 앱을 다른 노드로 스케줄링한다.</ul><h4 id="오토스케일링"><span class="mr-2">오토스케일링</span><a href="#오토스케일링" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>급격한 부하 급증에 대응하기 위해 개별 앱의 부하를 운영팀이 지속적으로 모니터링할 필요가 없다.<li>각 앱이 사용하는 리소스를 모니터링하고, 실행중인 인스턴스 수를 자동으로 조정하도록 지시할수 있다.</ul><h4 id="애플리케이션-개발-단순화"><span class="mr-2">애플리케이션 개발 단순화</span><a href="#애플리케이션-개발-단순화" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>개발과 프로덕션 환경이 모두 동일한 환경에서 실행된다는걸 보장할 수 있어서 버그발견시 큰 효과를 얻을수 있음.<li>또한 서비스 디스커버리와 같은 일반적으로 구현해야 하는 기능들을 구현할 필요가 없어졌다.<li>쿠버네티스 API 서버를 직접 쿼리하면 개발자가 리더 선정 같은 복잡한 메커니즘을 구현하지 않아도 된다.<li>새로운 버전의 앱을 출시할때 신버전이 잘못됐는지 자동으로 감지하고 즉시 롤아웃을 중지할수 있어서 신뢰성을 증가시켜 CD(continuous delivery)을 가속화할수 있음.</ul><h2 id="14-요약"><span class="mr-2">1.4 요약</span><a href="#14-요약" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>모놀리스 애플리케이션은 구축하기 쉽지만 시간이 지남에 따라 유지 관리가 어려워지고 때로는 확장이 불가능할수 있다.<li>마이크로서비스 기반 애플리케이션 아키텍처는 각 구성요소의 개발을 용이하게 하지만, 하나의 시스템으로 작동하도록 배포하고 구성하기가 어렵다.<li>리눅스 컨테이너는 가상머신과 동일한 이점을 제공하지만 훨씬 더 가볍고 하드웨어 활용도를 높일 수 있다.<li>도커는 OS환경과 함꼐 컨테이너화된 애플리케이션을 좀 더 쉽고 빠르게 프로비저닝할 수 있도록 지원해 기존 리눅스 컨테이너 기술을 개선했다.<li>쿠버네티스는 전체 데이터 센터를 앱 실행을 위한 컴퓨팅 리소스로 제공한다.<li>개발자는 시스템 관리자의 도움 없이도 쿠버네티스로 앱을 배포할 수 있다.<li>시스템 관리자는 쿠버네티스가 고장 난 노드를 자동으로 처리하도록 할수 있다.</ul><h2 id="reference"><span class="mr-2">Reference</span><a href="#reference" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><a href="https://www.manning.com/books/kubernetes-in-action">kubernetes-in-action</a><li><a href="https://kubernetes.io/ko/docs/home/">kubernetes.io</a></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/devlog/'>DevLog</a>, <a href='/categories/kubernetes/'>kubernetes</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/infra/" class="post-tag no-text-decoration" >Infra</a> <a href="/tags/kubernetes/" class="post-tag no-text-decoration" >kubernetes</a> <a href="/tags/kubernetes-in-action/" class="post-tag no-text-decoration" >kubernetes-in-action</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=[kubernetes-in-action]%201.%20%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%20%EC%86%8C%EA%B0%9C%20-%20Sungsu's%20Tech%20Blog&url=https%3A%2F%2Fsungsu9022.github.io%2Fposts%2Fdevlog-platform-kubernetes-in-action1%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=[kubernetes-in-action]%201.%20%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%20%EC%86%8C%EA%B0%9C%20-%20Sungsu's%20Tech%20Blog&u=https%3A%2F%2Fsungsu9022.github.io%2Fposts%2Fdevlog-platform-kubernetes-in-action1%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fsungsu9022.github.io%2Fposts%2Fdevlog-platform-kubernetes-in-action1%2F&text=[kubernetes-in-action]%201.%20%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%20%EC%86%8C%EA%B0%9C%20-%20Sungsu's%20Tech%20Blog" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/es-bible-4-3/">[엘라스틱서치 바이블] 4. 데이터 다루기 -3(ES Client 라이브러리)</a><li><a href="/posts/es-bible-4-2/">[엘라스틱서치 바이블] 4. 데이터 다루기 -2(집계)</a><li><a href="/posts/es-bible-2/">[엘라스틱서치 바이블] 2. 엘라스틱 서치 기본 동작과 구조</a><li><a href="/posts/es-bible-3-1/">[엘라스틱서치 바이블] 3. 인덱스 설계 - 1</a><li><a href="/posts/spark-guide-6/">[스파크 완벽 가이드] 6. 다양한 데이터 타입 다루기</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/spark/">Spark</a> <a class="post-tag" href="/tags/infra/">Infra</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/kubernetes-in-action/">kubernetes-in-action</a> <a class="post-tag" href="/tags/kubernetes/">kubernetes</a> <a class="post-tag" href="/tags/elasticsearch/">Elasticsearch</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/effective-java/">Effective Java</a> <a class="post-tag" href="/tags/hands-on-reactive-programming-in-spring-5/">Hands-On Reactive Programming in Spring 5</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/devlog-platform-kubernetes-in-action2/"><div class="card-body"> <em class="small" data-ts="1596357240" data-df="ll" > Aug 2, 2020 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[kubernetes-in-action] 2. 도커와 쿠버네티스 첫걸음</h3><div class="text-muted small"><p> 2. 도커와 쿠버네티스 첫걸음 2.1 도커를 사용한 컨테이너 이미지 생성, 실행, 공유하기 2.1.1 Hello World 컨테이너 실행하기 1 docker run busybox echp &quot;Hello world&quot; 백그라운드에 일어난 동작 이해하기 docker run 명령을 수행했을 떄 일어나는 일들 2.1.2 간단한 node.js 애...</p></div></div></a></div><div class="card"> <a href="/posts/devlog-platform-kubernetes-in-action3/"><div class="card-body"> <em class="small" data-ts="1596443640" data-df="ll" > Aug 3, 2020 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[kubernetes-in-action] 3. 파드 : 쿠버네티스에서 컨테이너 실행</h3><div class="text-muted small"><p> 3. 파드 : 쿠버네티스에서 컨테이너 실행 3.1 파드 소개 파드는 함께 배치된 컨테이너 그룹이며, 쿠버네티스의 기본 빌딩 블록. 컨테이너를 개별적으로 배포하기보다는 컨테이너를 가진 파드를 배포하고, 운영한다. 무조건 2개 이상을 컨테이너를 포함시키라는 의미는 아니고 일반적으로는 하나의 컨테이너만 포함된다. 파드의 핵심은 파드가 여러 ...</p></div></div></a></div><div class="card"> <a href="/posts/devlog-platform-kubernetes-in-action4/"><div class="card-body"> <em class="small" data-ts="1596789240" data-df="ll" > Aug 7, 2020 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[kubernetes-in-action] 4. 레플리케이션과 그 밖의 컨트롤러 : 관리되는 파드 배포</h3><div class="text-muted small"><p> 4. 레플리케이션과 그 밖의 컨트롤러 : 관리되는 파드 배포 4.1 파드를 안정적으로 유지하기 쿠버네티스를 사용하면 얻을 수 있는 주요 이점은 쿠버네티스에 컨테이너 목록을 제공하면 해당 컨테이너를 클러스터 어딘가에서 계속 실행되도록 할수 있는 것이다. 파드가 노드에 스케줄링되면 노드의 Kubelet은 이 파드가 존재하는 한 컨테이너가 계속 실...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/devlog-java-algolithm3/" class="btn btn-outline-primary" prompt="Older"><p>[HackerRank] Java Anagrams</p></a> <a href="/posts/devlog-platform-kubernetes-in-action2/" class="btn btn-outline-primary" prompt="Newer"><p>[kubernetes-in-action] 2. 도커와 쿠버네티스 첫걸음</p></a></div><div id="disqus_thread" class="pt-2 pb-2"><p class="text-center text-muted small">Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script type="text/javascript"> var disqus_config = function () { this.page.url = 'https://sungsu9022.github.io/posts/devlog-platform-kubernetes-in-action1/'; this.page.identifier = '/posts/devlog-platform-kubernetes-in-action1/'; }; /* Lazy loading */ var disqus_observer = new IntersectionObserver( function (entries) { if (entries[0].isIntersecting) { (function () { var d = document, s = d.createElement('script'); s.src = 'https://sungsu-parks-tech-blog.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); disqus_observer.disconnect(); } }, { threshold: [0] } ); disqus_observer.observe(document.querySelector('#disqus_thread')); /* Auto switch theme */ function reloadDisqus() { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* Disqus hasn't been loaded */ if (typeof DISQUS === 'undefined') { return; } if (document.readyState == 'complete') { DISQUS.reset({ reload: true, config: disqus_config }); } } } if (document.querySelector('.mode-toggle')) { window.addEventListener('message', reloadDisqus); } </script></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/spark/">Spark</a> <a class="post-tag" href="/tags/infra/">Infra</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/kubernetes-in-action/">kubernetes-in-action</a> <a class="post-tag" href="/tags/kubernetes/">kubernetes</a> <a class="post-tag" href="/tags/elasticsearch/">Elasticsearch</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/effective-java/">Effective Java</a> <a class="post-tag" href="/tags/hands-on-reactive-programming-in-spring-5/">Hands-On Reactive Programming in Spring 5</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://twitter.com/sungsu9022dev">sungsu9022</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0">Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></div></footer><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-145894105-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-145894105-1'); }); </script>
