<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.3.3" /><meta property="og:title" content="이펙티브 자바 3판 - 3. 모든 객체의 공통 메서드" /><meta name="author" content="sungsu park" /><meta property="og:locale" content="en" /><meta name="description" content="이펙티브 자바 3판 - 3. 모든 객체의 공통 메서드 Item10. equals 는 일반 규약을 지켜 재정의하라 Item11. equals를 재정의하려거든 hashCode도 재정의하라 Item12. toString을 항상 재정의하라 Item13. clone 재 정의는 주의해서 진행해라. Item14. Comparable을 구현할지 고려하라." /><meta property="og:description" content="이펙티브 자바 3판 - 3. 모든 객체의 공통 메서드 Item10. equals 는 일반 규약을 지켜 재정의하라 Item11. equals를 재정의하려거든 hashCode도 재정의하라 Item12. toString을 항상 재정의하라 Item13. clone 재 정의는 주의해서 진행해라. Item14. Comparable을 구현할지 고려하라." /><link rel="canonical" href="https://sungsu9022.github.io/posts/devlog-effective-java-3e-3/" /><meta property="og:url" content="https://sungsu9022.github.io/posts/devlog-effective-java-3e-3/" /><meta property="og:site_name" content="Sungsu’s Tech Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-05-17T17:34:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="이펙티브 자바 3판 - 3. 모든 객체의 공통 메서드" /><meta name="twitter:site" content="@sungsu9022dev" /><meta name="twitter:creator" content="@sungsu park" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"sungsu park"},"dateModified":"2020-05-17T17:34:00+09:00","datePublished":"2020-05-17T17:34:00+09:00","description":"이펙티브 자바 3판 - 3. 모든 객체의 공통 메서드 Item10. equals 는 일반 규약을 지켜 재정의하라 Item11. equals를 재정의하려거든 hashCode도 재정의하라 Item12. toString을 항상 재정의하라 Item13. clone 재 정의는 주의해서 진행해라. Item14. Comparable을 구현할지 고려하라.","headline":"이펙티브 자바 3판 - 3. 모든 객체의 공통 메서드","mainEntityOfPage":{"@type":"WebPage","@id":"https://sungsu9022.github.io/posts/devlog-effective-java-3e-3/"},"url":"https://sungsu9022.github.io/posts/devlog-effective-java-3e-3/"}</script><title>이펙티브 자바 3판 - 3. 모든 객체의 공통 메서드 | Sungsu's Tech Blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Sungsu's Tech Blog"><meta name="application-name" content="Sungsu's Tech Blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/personal/sunny.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">Sungsu's Tech Blog</a></div><div class="site-subtitle font-italic">Java/Kotlin Spring, Back-end</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/sungsu9022" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/sungsu9022dev" aria-label="twitter" target="_blank" rel="noopener noreferrer"> <i class="fab fa-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['sungsu9022','naver.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>이펙티브 자바 3판 - 3. 모든 객체의 공통 메서드</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>이펙티브 자바 3판 - 3. 모든 객체의 공통 메서드</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1589704440" data-df="ll" data-toggle="tooltip" data-placement="bottom"> May 17, 2020 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href=""></a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="7216 words"> <em>40 min</em> read</span></div></div></div><div class="post-content"><h1 id="이펙티브-자바-3판---3-모든-객체의-공통-메서드">이펙티브 자바 3판 - 3. 모든 객체의 공통 메서드</h1><ul><li><a href="#item10">Item10. equals 는 일반 규약을 지켜 재정의하라</a><li><a href="#item11">Item11. equals를 재정의하려거든 hashCode도 재정의하라 </a><li><a href="#item12">Item12. toString을 항상 재정의하라</a><li><a href="#item13">Item13. clone 재 정의는 주의해서 진행해라.</a><li><a href="#item14">Item14. Comparable을 구현할지 고려하라.</a></ul><h2 id="item10-equals-는-일반-규약을-지켜-재정의하라"><span class="mr-2"><a id="item10">Item10. equals 는 일반 규약을 지켜 재정의하라</a></span><a href="#item10-equals-는-일반-규약을-지켜-재정의하라" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><blockquote><p>equals 재정의하는데 있어서 곳곳에 합정이 있으며, 자칫 잘못하면 끔찍한 결과를 초래할 수 있음. 이를 회피하는 가장 쉬운 길은 아예 재정의하지 않는 것이지만 실제로 개발하다보면 재정의가 필요한 경우도 있을수 있다.(물론 lombok을 사용하면 조금 더 쉬워진다.)</p></blockquote><h3 id="재정의를-하지-않아야-하는-상황"><span class="mr-2">재정의를 하지 않아야 하는 상황</span><a href="#재정의를-하지-않아야-하는-상황" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>각 인스턴스가 본질적으로 고유한 경우(값을 표현하는게 아니라 동작하는 개체를 표현하는 클래스<ul><li>Thread 클래스 같은것, 추가로 우리가 개발하는 Spring bean용 클래스의 경우를 생각해도 좋을 것 같다.</ul><li>인스턴스의 논리적 동치성(logical equality)을 검사할 일이 없는 경우<ul><li>Pattern클래스의 인스턴스 2개가 같은 정규표현식을 나타내는지 검사하는것과 같은 행위(논리적 동치성 검사)<li>설계자는 이 방식을 원하지 않거나 애초에 필요하지 않다고 판단할 수도 있음.</ul><li>상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞는 경우<ul><li>Collection 클래스류와 같은..</ul><li>클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없는 경우</ul><h3 id="equals를-재정의를-해야-하는-상황"><span class="mr-2">equals를 재정의를 해야 하는 상황</span><a href="#equals를-재정의를-해야-하는-상황" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>객체 식별성(object identity, 두 객체가 물리적으로 같은지?)이 아니라 논리적 동치성을 확인해야 하는데, 상위 클래스의 equals가 논리적 동치성을 비교하도록 재정의되지 않은 경우<li>위에 정의된 말이 조금 이해가 어려운데 쉽게 풀이하면<ul><li>값 클래스 (Interger, String ..)<li>값이 같은 인스턴스가 둘 이상 만들어지지 않음을 보장하는 인스턴스 통제 클래스<ul><li>Boolean.TRUE, Boolean,FALSE, Enum류 등</ul><li>비즈니스 로직에서 사용할 Entity Class 적절히 PK로 활용될 수 있는 데이터셋을 기준으로 equals를 구현할수 있음</ul></ul><h3 id="equals-재정의할때-따라야할-일반-규약"><span class="mr-2">equals 재정의할때 따라야할 일반 규약</span><a href="#equals-재정의할때-따라야할-일반-규약" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>equals 메서드는 동치 관계(equivalence relation)을 구현하며, 다음을 만족</p><ul><li>반사성(reflexivity) : null이 아닌 모든 참조 값 x에 대해 x.equals(x)는 true<li>대칭성(symmetry) : null이 아닌 모든 참조 값 x,y에 대해 x.equals(y)가 true면 y.equals(x)도 true<li>추이성(transitivity) : null이 아닌 모든 참조 값 x,y,z에 대해 x.equals(y)가 true이고, y.equals(z)가 true면 x.equals(z)도 true다.<li>일관성(consistency) : null이 아닌 모든 참조 값 x,y에 대해 x.equals(y)를 반복해서 호출해도 항상 true 또는 false만을 반환<li>null-아님 : null이 아닌 모든 참조값 x에 대해 x.equals(null)은 false이다.</ul><h3 id="대칭성symmetry"><span class="mr-2">대칭성(symmetry)</span><a href="#대칭성symmetry" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">CaseInsenstiveString</span><span class="o">{</span>
     <span class="kd">private</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">s</span><span class="o">;</span>
     <span class="kd">public</span> <span class="nf">CaseInsensitiveString</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">){</span>
         <span class="k">this</span><span class="o">.</span><span class="na">s</span> <span class="o">=</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">requireNorNull</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
     <span class="o">}</span>
 <span class="o">}</span>

<span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">CaseInsensitiveString</span><span class="o">)</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">equalsIgnoreCase</span><span class="o">(</span>
                <span class="o">((</span><span class="nc">CaseInsensitiveString</span><span class="o">)</span> <span class="n">o</span><span class="o">).</span><span class="na">s</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">String</span><span class="o">)</span>  <span class="c1">// 한 방향으로만 작동한다!</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">equalsIgnoreCase</span><span class="o">((</span><span class="nc">String</span><span class="o">)</span> <span class="n">o</span><span class="o">);</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>CaseInsensitiveString.equals(String) 에서는 동작하지만 String.equals(CaseInsensitiveString)에서는 동작하지 않고 한방향으로만 작동하기 때문에 대칭성을 명백히 위반하게 됨.</ul><h3 id="추이성transitivity"><span class="mr-2">추이성(transitivity)</span><a href="#추이성transitivity" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>null이 아닌 모든 참조 값 x,y,z에 대해 x.equals(y)가 true이고, y.equals(z)가 true면 x.equals(z)도 true다.</ul><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Point</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">x</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">y</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Point</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(!(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">Point</span><span class="o">))</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="nc">Point</span> <span class="n">p</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Point</span><span class="o">)</span><span class="n">o</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="na">x</span> <span class="o">==</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">.</span><span class="na">y</span> <span class="o">==</span> <span class="n">y</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ColorPoint</span> <span class="kd">extends</span> <span class="nc">Point</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Color</span> <span class="n">color</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">ColorPoint</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">,</span> <span class="nc">Color</span> <span class="n">color</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="n">color</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 대칭성 위배</span>
<span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(!(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">ColorPoint</span><span class="o">))</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">o</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">((</span><span class="nc">ColorPoint</span><span class="o">)</span> <span class="n">o</span><span class="o">).</span><span class="na">color</span> <span class="o">==</span> <span class="n">color</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 추이성 위배</span>
<span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(!(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">Point</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

   <span class="c1">// o가 일반 Point면 색상을 무시하고 비교한다.</span>
    <span class="k">if</span> <span class="o">(!(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">ColorPoint</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">o</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="nc">ColorPoint</span> <span class="n">cp</span> <span class="o">=</span> <span class="o">(</span><span class="nc">ColorPoint</span><span class="o">)</span> <span class="n">o</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">cp</span><span class="o">.</span><span class="na">point</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">point</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">cp</span><span class="o">.</span><span class="na">color</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">color</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>대칭성 위배 코드를 살펴보면 Point의 equals는 색상을 무시하고, ColorPoint의 equals는 입력 매개변수의 클래스 종류가 다르다며 매번 false를 반환하게 된다.<li><p>추이성 위배 코드를 살펴보면 대칭성은 지켜주지만 추이성을 깨버린다.</p><li><p>구체 클래스를 확장해 새로운 값을 추가하면서 equals 규약을 만족시킬 방법은 존재하지 않는다…(객체 지향적 추상화의 이점을 포기하지 않는 한)</p><li>리스코프 치환 원칙(Liskov substitution principle)<ul><li>어떤 타입에 잇어 중요한 속성이라면 그 하위 타입에서도 마찬가지로 중요. 타입의 모든 메서드가 하위 타입에서도 똑같이 잘 동작해야 함.<li>Point를 기준으로 풀이하면 Point의 모든 하위 클래스는 정의상 모두 Point이므로 어디서든 Point 타입으로 활용될 수 있어야 한다는 말</ul></ul><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="c1">// 리스코프 치환법칙 위배</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">o</span><span class="o">.</span><span class="na">getClass</span><span class="o">()</span> <span class="o">!=</span> <span class="n">getClass</span><span class="o">())</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="nc">Point</span> <span class="n">p</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Point</span><span class="o">)</span> <span class="n">o</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="na">x</span> <span class="o">==</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">.</span><span class="na">y</span> <span class="o">==</span> <span class="n">y</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>위와 같이 equals를 구현해둔 경우에 Point의 하위 클래스를 정의하고 이를 Set과 같은 컬렉션에 넣어서 처리를 하고자하면 재대로 동작하지 않는걸 확인할 수 있다. 이 원인은 Colletion.contains 동작방식에 있음<li>Colletion.contains(Object o) 동작방식<ul><li>대부분의 Collection interface 구현체 대부분은 contains을 판단하는데 있어서 객체의 equals 메서드를 사용하여 검증하므로 이 구현이 의도된대로 정의되어있어야 함.</ul><li>이 문제를 해결할 수 있는 대표적인 방법은 “상속 대신 컴포지션을 사용하는 것”이다.<ul><li>상위 클래스 타입의 변수를 멤버로 두고 그것을 반환하는 뷰 메소드를 public으로 작성한다.<li>아무 값도 갖지 않는 클래스를 베이스로 두고 확장한다.(베이스 클래스를 인스턴스하지 않기 때문에 위배되지 않는다)</ul></ul><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ColorPoint</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Point</span> <span class="n">point</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Color</span> <span class="n">color</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">ColorPoint</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">,</span> <span class="nc">Color</span> <span class="n">color</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">point</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Point</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">requireNonNull</span><span class="o">(</span><span class="n">color</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 이 ColorPoint의 Point 뷰를 반환한다.
     */</span>
    <span class="kd">public</span> <span class="nc">Point</span> <span class="nf">asPoint</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">point</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(!(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">ColorPoint</span><span class="o">))</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="nc">ColorPoint</span> <span class="n">cp</span> <span class="o">=</span> <span class="o">(</span><span class="nc">ColorPoint</span><span class="o">)</span> <span class="n">o</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">cp</span><span class="o">.</span><span class="na">point</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">point</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">cp</span><span class="o">.</span><span class="na">color</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">color</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="일관성consistency"><span class="mr-2">일관성(consistency)</span><a href="#일관성consistency" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>null이 아닌 모든 참조 값 x,y에 대해 x.equals(y)를 반복해서 호출해도 항상 true 또는 false만을 반환<li>두 객체가 같다면 앞으로도 영원히 같아야 한다는 의미<li>클래스를 작성할때 불변 클래스로 만드는게 나을지를 심사숙고하자.<li>equals의 판단에 신뢰할 수 없는 자원이 끼어들게 해서는안된다.<ul><li>java.net.URL의 equals가 예다. URL과 ip의 호스트를 비교하는데 이때 네트웍을 통하게 된다.</ul></ul><h3 id="null-아님"><span class="mr-2">null-아님</span><a href="#null-아님" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>동치성 검사를 위해 적절한 형변환 후 값을 비교한다.<li>instanceof는 비교하는 객체가 null 인지 검사한다.(그래서 ==null 을 할 필요 없다)</ul><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="c1">// 명시적 null 검사 필요 없음.</span>
<span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
   <span class="k">if</span><span class="o">(!(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">MyType</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
   <span class="o">}</span>
  <span class="nc">MyType</span> <span class="n">type</span> <span class="o">=</span> <span class="o">(</span><span class="nc">MyType</span><span class="o">)</span> <span class="n">o</span><span class="o">;</span>
   <span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="equals-메서드-단계별-구현-방법"><span class="mr-2">equals 메서드 단계별 구현 방법</span><a href="#equals-메서드-단계별-구현-방법" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>1) == 연산자를 사용해 입력이 자기 자신의 참조인지 확인.<li>2) instanceof 연산자로 입력이 올바른 타입인지 확인.<li>3) 입력을 올바른 타입으로 형변환<li>4) 입력 객체와 자기 자신의 대응되는 핵심 필드들이 모두 일치하는지 하나씩 검사</ul><h3 id="equals-관련-팁"><span class="mr-2">equals 관련 팁</span><a href="#equals-관련-팁" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>primitive type (float, double 제외) 는 “==” 연산자로 비교하고, 레퍼런스 타입 필드는 equals 메서드로 비교한다.<li>float,double은 wrapper class 의 static method인 compare 메서드로 비교한다.<ul><li>이렇게 특별취급하는 이유는 NaN, -0.0f, 특수한 부정소수 값 등을 다뤄야 하기 때문<li>wrapper class의 equals를 사용할수도 있는데 오토박싱을 수반할 수 있어서 성능상 좋지 않을 수 있음</ul><li>성능이 걱정된다면 cost가 적을 것 같은 필드부터 비교한다.<li>동기화용 락(lock) 필드 같은 논리적 상태와 관련 없는 필드는 연산하지 말자. (논리적 상태만을 비교하자)<li><p>캐쉬된 값을 저장하는 파생클래스 변수가 있을 경우 활용하자.</p><li>완벽한 equals 를 보여주는 코드<div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">PhoneNumber</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="kt">short</span> <span class="n">areaCode</span><span class="o">,</span> <span class="n">prefix</span><span class="o">,</span> <span class="n">lineNum</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">PhoneNumber</span><span class="o">(</span><span class="kt">int</span> <span class="n">areaCode</span><span class="o">,</span> <span class="kt">int</span> <span class="n">prefix</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lineNum</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">this</span><span class="o">.</span><span class="na">areaCode</span> <span class="o">=</span> <span class="n">rangeCheck</span><span class="o">(</span><span class="n">areaCode</span><span class="o">,</span> <span class="mi">999</span><span class="o">,</span> <span class="s">"지역코드"</span><span class="o">);</span>
      <span class="k">this</span><span class="o">.</span><span class="na">prefix</span>   <span class="o">=</span> <span class="n">rangeCheck</span><span class="o">(</span><span class="n">prefix</span><span class="o">,</span>   <span class="mi">999</span><span class="o">,</span> <span class="s">"프리픽스"</span><span class="o">);</span>
      <span class="k">this</span><span class="o">.</span><span class="na">lineNum</span>  <span class="o">=</span> <span class="n">rangeCheck</span><span class="o">(</span><span class="n">lineNum</span><span class="o">,</span> <span class="mi">9999</span><span class="o">,</span> <span class="s">"가입자 번호"</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">private</span> <span class="kd">static</span> <span class="kt">short</span> <span class="nf">rangeCheck</span><span class="o">(</span><span class="kt">int</span> <span class="n">val</span><span class="o">,</span> <span class="kt">int</span> <span class="n">max</span><span class="o">,</span> <span class="nc">String</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">max</span><span class="o">)</span>
          <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="n">arg</span> <span class="o">+</span> <span class="s">": "</span> <span class="o">+</span> <span class="n">val</span><span class="o">);</span>
      <span class="k">return</span> <span class="o">(</span><span class="kt">short</span><span class="o">)</span> <span class="n">val</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="o">==</span> <span class="k">this</span><span class="o">)</span>
          <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
      <span class="k">if</span> <span class="o">(!(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">PhoneNumber</span><span class="o">))</span>
          <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
      <span class="nc">PhoneNumber</span> <span class="n">pn</span> <span class="o">=</span> <span class="o">(</span><span class="nc">PhoneNumber</span><span class="o">)</span><span class="n">o</span><span class="o">;</span>
      <span class="k">return</span> <span class="n">pn</span><span class="o">.</span><span class="na">lineNum</span> <span class="o">==</span> <span class="n">lineNum</span> <span class="o">&amp;&amp;</span> <span class="n">pn</span><span class="o">.</span><span class="na">prefix</span> <span class="o">==</span> <span class="n">prefix</span>
              <span class="o">&amp;&amp;</span> <span class="n">pn</span><span class="o">.</span><span class="na">areaCode</span> <span class="o">==</span> <span class="n">areaCode</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div></ul><h3 id="추가-코멘트"><span class="mr-2">추가 코멘트</span><a href="#추가-코멘트" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>Java Platform 내에서 equlas의 역할, 어떻게 동작하는가 이런 개념적인 내용은 Java 개발자라면 필수로 알고 있어야 하는 개념들이라고 생각합니다. 실제로 실무에서 이렇게 equlas 메서드를 직접 구현하는케이스는 상당히 드믈것이라 생각되는데요.<li>이미 Lombok 등 다른대안들이 많이 있으니깐요. 하지만 그렇다고 이 개념들을 알 필요가 없는것은 아닙니다.</ul><h2 id="item11-equals를-재정의하려거든-hashcode도-재정의하라"><span class="mr-2"><a id="item11">Item11. equals를 재정의하려거든 hashCode도 재정의하라</a></span><a href="#item11-equals를-재정의하려거든-hashcode도-재정의하라" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><blockquote><p>equals를 재정의한 클래스 모두에서 hashCode도 재정의해야 한다. (Lombok의 annotation이 @EqulasAndHashCode 로 묶어둔 이유기도 함.)</p></blockquote><h3 id="hashcode-관련-규약object-명세"><span class="mr-2">hashCode 관련 규약(Object 명세)</span><a href="#hashcode-관련-규약object-명세" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>1) equals 비교에 사용되는 정보가 변경되지 않았다면 해당 객체의 hashCode는 몇 번을 호출해도 일관된 값을 반환해야 한다.<li>2) equals(Object)가 두 객체를 같다고 판단했다면 hashCode도 같은 값을 반환해야 한다.<li>3) equals(Object)가 두 객체를 다르다고 판단했더라도, 두 객체의 hashCode가 서로 다른 값을 반환할 필요는 없다. 단, 다른 객체에 대해서는 다른 값을 반환해야 해시 테이블의 성능이 좋아진다는 것을 알아야 한다.</ul><h3 id="hashcode-일반-규약을-어기는-경우-hashmap-hashset등에서-문제가-발생한다"><span class="mr-2">hashCode 일반 규약을 어기는 경우 HashMap, hashSet등에서 문제가 발생한다.</span><a href="#hashcode-일반-규약을-어기는-경우-hashmap-hashset등에서-문제가-발생한다" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>위 2번 조항의 내용과 연관성이 있는데 같은 객체라면 같은 해시코드를 반환해야 hashMap, hashSet에 유일하게 저장될 수 있다.</ul><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">PhonNumber</span><span class="o">,</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Hashmap</span><span class="o">&lt;&gt;();</span>
<span class="n">m</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="k">new</span> <span class="nc">PhoneNumber</span><span class="o">(</span><span class="mi">707</span><span class="o">,</span> <span class="mi">867</span><span class="o">,</span> <span class="mi">5309</span><span class="o">),</span><span class="s">"jenny"</span><span class="o">);</span>
<span class="n">m</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="k">new</span> <span class="nc">PhoneNumber</span><span class="o">(</span><span class="mi">707</span><span class="o">,</span> <span class="mi">867</span><span class="o">,</span> <span class="mi">5309</span><span class="o">));</span>
</pre></table></code></div></div><ul><li>jenny가 나올것 같지만, 실제 결과는 null<li>넣을때 한번, 꺼낼때 한번 객체를 생성했다. 이들은 논리적 동치이나. 둘의 hashCode가 다르기 때문에 HashMap에서 찾을 수 없음.이 케이스로 꼭 해야 겠다면 put한 객체를 로컬변수로 저장한 뒤 해당 객체를 get()의 파라메터로 넘겨야 한다.</ul><h3 id="절대로-하지-말아야-할-hashcode-구현-행위"><span class="mr-2">절대로 하지 말아야 할 hashCode 구현 행위</span><a href="#절대로-하지-말아야-할-hashcode-구현-행위" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nd">@override</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashcode</span><span class="o">(){</span> <span class="k">return</span> <span class="mi">42</span><span class="o">;}</span>
</pre></table></code></div></div><ul><li>학창시절 HashTable의 시간복잡도를 배우면서 O(1)의 엄청난 성능을 보이는것으로 배웠을텐데, 위처럼 모든 객체가 같은 hashCode를 return하도록 한다면 O(n)의 성능을 만들어낼 수 있다. 모든 해쉬가 같기 때문에 결국 Linked List처럼 동작하게 된다.<li><a href="https://ratsgo.github.io/data%20structure&amp;algorithm/2017/10/25/hash/">hash 관련된 내용이잘 설명되어 있는 블로그</a></ul><h3 id="일반적으로-hashcoed-method를-만드는-방법"><span class="mr-2">일반적으로 hashCoed method를 만드는 방법</span><a href="#일반적으로-hashcoed-method를-만드는-방법" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nd">@Override</span>
<span class="c1">// PhoneNumber.java의 예</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="nc">Short</span><span class="o">.</span><span class="na">hashCode</span><span class="o">(</span><span class="n">areaCode</span><span class="o">);</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">31</span> <span class="o">*</span> <span class="n">result</span> <span class="o">+</span> <span class="nc">Short</span><span class="o">.</span><span class="na">hashCode</span><span class="o">(</span><span class="n">prefix</span><span class="o">);</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">31</span> <span class="o">*</span> <span class="n">result</span> <span class="o">+</span> <span class="nc">Short</span><span class="o">.</span><span class="na">hashCode</span><span class="o">(</span><span class="n">lineNum</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>31을 곱하는 이유는 31이 홀수이면서 소수(prime)이기 떄문<li>이렇게 복잡한 연산으로 hashCode를 만드는 이유는 hash conflict를 최대한 막아 hash 분포를 잘되게 하여 좋은 성능을 유지시키기 위함이다.<li>hash conflict을 더욱 적은 방법을 쓰려고 할떄 고려사항 구아바의 com.google.common.hash.Hashing 참조<ul><li>조금 살펴봤는데 충돌을 피하기 위한 여러 알고리즘을 적용된 HashFunction을 생성해주는 Util Class네요.<li>실제로 매우 많은 데이터를 JVM 위에 올려놓고 하나의 Hash Collection을 이용하는 경우 특정 모델의 성능 향상을 위해서 저런 Util을 써볼수 있을 것 같은데 일반적인 엔터프라이즈 웹 애플리케이션 개발에서는 사용하지 않을 가능성이 높아 보이긴 합니다.</ul><li>성능을 고려하는 목적으로 핵심필드를 빼고 hashcode를 정의하지 말자.(해시테이블 성능을 놓치게된다)</ul><h2 id="item12-tostring을-항상-재정의하라"><span class="mr-2"><a id="item12">Item12. toString을 항상 재정의하라.</a></span><a href="#item12-tostring을-항상-재정의하라" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>default 동작은 “클래스_이름@16진수로_표시한_해시코드”가 반환됨.<li>위 정보는 아주 쓸모가 없음..</ul><h3 id="항상-적합한-문자열을-반환하지-않는다"><span class="mr-2">항상 적합한 문자열을 반환하지 않는다.</span><a href="#항상-적합한-문자열을-반환하지-않는다" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>PhoneNumber@adbbb (클래스이름@16진수해쉬코드) 를 반환한다.<li>하위 클래스에서는 간결하고 읽기 쉬운(핵심필드 들을) 형태로 toString을 정의해주는 것이 좋다.<li>문제(디버깅)에 용이하게 만든다.<li>모든 핵심 필드들을 출력하는 것이 좋다. ``` /**<ul><li>이 전화번호의 문자열 표현을 반환한다.<li>이 문자열은 “XXX-YYY-ZZZZ” 형태의 12글자로 구성된다.<li>XXX는 지역 코드, YYY는 프리픽스, ZZZZ는 가입자 번호다.<li>각각의 대문자는 10진수 숫자 하나를 나타낸다. *<li>전화번호의 각 부분의 값이 너무 작아서 자릿수를 채울 수 없다면,<li>앞에서부터 0으로 채워나간다. 예컨대 가입자 번호가 123이라면<li>전화번호의 마지막 네 문자는 “0123”이 된다. */ @Override public String toString() { return String.format(“%03d-%03d-%04d”, areaCode, prefix, lineNum); } ```</ul><li>하위 클래스에서 상위클래스의 적절한 toString이 있다면 말고 없다면 꼭 구현해주는것이 좋다.</ul><h3 id="코멘트"><span class="mr-2">코멘트</span><a href="#코멘트" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>사실 여기에 대한 생각은 log를 남기거나 하는 경우에 해당 클래스의 정보를 표시해주어야 하므로 그런 경우에만 toString을 구현해주는것이 맞는듯 하기도 하다. Lombok을 사용하는 경우에 @ToString만 붙여주면 아주 예쁘게 노출되기 떄문에 실제로 어려운일이 아니기도 하고 말이다.<li>사실 ToString 관련해서는 책에서 다루는 개념적으로 아주 중요한 내용은 없는듯 하다.</ul><h2 id="item13-clone-재-정의는-주의해서-진행해라"><span class="mr-2"><a id="item13">Item13. clone 재 정의는 주의해서 진행해라.</a></span><a href="#item13-clone-재-정의는-주의해서-진행해라" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="cloneable-interface"><span class="mr-2">Cloneable interface</span><a href="#cloneable-interface" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>복제해도 되는 클래스임을 명시하는 용도의 믹스인 인터페이스<li>아쉽게도 의도한 목적을 제대로 이루지 못했음..<li>가장 큰 문제는 clone 메서드가 선언된 곳이 Cloneable이 아닌 Object라는 것(심지어 protected )<li>이런 내용을 보면 Cloneable 인터페이스가 하는일이 없어보이지만 동작방식을 살펴보면 용도가 있긴 있다.</ul><h3 id="objectclone-동작-방식"><span class="mr-2">Object.clone 동작 방식</span><a href="#objectclone-동작-방식" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>Object.clone은 Cloneable을 구현한 클래스의 인스턴스에서 호출하면 해당 객체의 필드들을 하나하나 복사한 객체를 반환<li>그렇지 않은 클래스의 인스턴스에서 호출하면 CloneNotSupportedExpcetion을 반환한다.</ul><h3 id="clone으로-파생되는-문제"><span class="mr-2">clone으로 파생되는 문제</span><a href="#clone으로-파생되는-문제" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>Cloneable을 구현한 클래스는 clone 메서드를 public으로 제공하며, 사용자는 당연히 복제가 재대로 이뤄지리라 기대한다. 하지만 모순적인 매커니즘이 탄생할수 있고, 생성자를 호출하지 않고도 객체를 생성하면서 모순적인 매커니즘이 탄생한다.<li>상속 구조에 있는 클래스에서 clone 메서드가 super.clone이 아닌 생성자를 호출해 얻은 인스턴스를 반환하더라도 컴파일 에러는 없을텐데, 이 경우 하위 클래스에서 super.clone()을 호출한 경우 잘못된 클래스의 객체가 만들어져서 결국 하위 클래스의 clone 메서드가 재대로 동작하지 않을수 있음.<li>쓸데없는 복사를 지양한다는 관점에서는 굳이 clone 메서드를 제공하지 않는게 좋다.</ul><h3 id="공변-반환-타이핑convariant-return-typing"><span class="mr-2">공변 반환 타이핑(convariant return typing)</span><a href="#공변-반환-타이핑convariant-return-typing" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>재정의한 메서드의 반환 타입은 상위 클래스의 메서드의 반환하는 타입의 하위 타입일 수 있다는 의미<li>이 주제를 벗어나기도 해서 일단은 간략하게 이야기하면 클래스 상속 구조가 아래와 같다고 할때 return type이 Animal이더라도 Dog 객체는 Animal을 구현한 하위 클래스의 객체를 반환할 수 있다고 쉽게 생각해도 좋을 것 같다.</ul><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
 <span class="o">...</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{</span>
 <span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="클래스가-가변-객체를-참조하느-경우의-clone"><span class="mr-2">클래스가 가변 객체를 참조하느 경우의 clone</span><a href="#클래스가-가변-객체를-참조하느-경우의-clone" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="c1">// Stack의 복제 가능 버전 (80-81쪽)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Stack</span> <span class="kd">implements</span> <span class="nc">Cloneable</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">elements</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">DEFAULT_INITIAL_CAPACITY</span> <span class="o">=</span> <span class="mi">16</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Stack</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">elements</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">[</span><span class="no">DEFAULT_INITIAL_CAPACITY</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">push</span><span class="o">(</span><span class="nc">Object</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">ensureCapacity</span><span class="o">();</span>
        <span class="n">elements</span><span class="o">[</span><span class="n">size</span><span class="o">++]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">pop</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">EmptyStackException</span><span class="o">();</span>
        <span class="nc">Object</span> <span class="n">result</span> <span class="o">=</span> <span class="n">elements</span><span class="o">[--</span><span class="n">size</span><span class="o">];</span>
        <span class="n">elements</span><span class="o">[</span><span class="n">size</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// 다 쓴 참조 해제</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isEmpty</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">size</span> <span class="o">==</span><span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 원소를 위한 공간을 적어도 하나 이상 확보한다.</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">ensureCapacity</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">elements</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="n">size</span><span class="o">)</span>
            <span class="n">elements</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">copyOf</span><span class="o">(</span><span class="n">elements</span><span class="o">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li><p>clone 메서드가 단순히 super.clone의 결과를 그대로 반환한다면 size 필드는 올바른 값을 갖겠지만, elements 필드는 원본 Stack 인스턴스와 똑같은 배열을 참조하고 있다. 원본이나 복제본 중 하나를 수정하면 다른 하나도 수정되어 불변식을 해칠수 있고, 프로그램이 이상하게 동작하거나 NPE가 발생할 수 있다.(생성자를 호출해서 만든 객체였다면 이런일은 벌어지지 않았을것이지만, clone은 사실상 생성자와 같은 효과를 냄)</p><li><p>clone은 원본 객체에 아무런 해를 끼치지 않는 동시에 복제된 객체의 불변식을 보장해야 함.</p></ul><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>    <span class="c1">// 코드 13-2 가변 상태를 참조하는 클래스용 clone 메서드</span>
    <span class="nd">@Override</span> <span class="kd">public</span> <span class="nc">Stack</span> <span class="nf">clone</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">Stack</span> <span class="n">result</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Stack</span><span class="o">)</span> <span class="kd">super</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
            <span class="n">result</span><span class="o">.</span><span class="na">elements</span> <span class="o">=</span> <span class="n">elements</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">CloneNotSupportedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">AssertionError</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
</pre></table></code></div></div><ul><li>이렇게 처리한다면 위 문제를 해결할수 있겠지만, Cloneable 아키텍처는 ‘가변 객체를 참조하는 필드는 final로 선언하라’는 일반 용법과 충돌이 발생함.(여기서 elemtns와 같은 가변 객체 참조 필드는 실제로 final로 선언되어있어야 하는데 그렇다면 위와 같은 clone 방식으로 처리할 수가 없는것임)</ul><h3 id="clone-정의시-주의사항"><span class="mr-2">clone 정의시 주의사항</span><a href="#clone-정의시-주의사항" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>생성자에서는 재정의될 수 있는 메서드를 호출하지 않아야 함.<li>상속용 클래스는 Cloneable을 구현해서는 안된다.<li>Cloneable을 구현한 스레드 안전 클래스를 작성할 때는 clone 메서드 역시 적절히 동기화해줘야 한다.</ul><h3 id="clone-정의-방법"><span class="mr-2">clone 정의 방법</span><a href="#clone-정의-방법" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>Clonealbe을 구현하는 모든 클래스는 clone을 재정의 해야 하고, 접근제한자는 public으로 반환 타입은 클래스 자신으로 변경한다.<li>super.clone() 호출 후 필요한 필드를 전부 적절히 수정(모든 가변 객체를 복사해야함.)</ul><h3 id="언제-clone을-구현해야-할까"><span class="mr-2">언제 clone을 구현해야 할까?</span><a href="#언제-clone을-구현해야-할까" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>위에 나열되있는것처럼 모든 가변 객체를 copy해주는 등 clone 구현시에는 복잡한 작업들이 뒤따른다. 그러면 꼭 이렇게까지 구현을 해야하는것일까?<li>Cloneable을 이미 구현한 클래스를확장하는 경우 어쩔 수 없이 clone을 잘 작동하도록 구현해야 한다. 그렇지 않은 상황에서는 더 나은 객체복사 방식을 사용하자(복사 생성자, 복사 팩토리와 같은)</ul><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1">// 복사 생성자(conversion constructor)</span>
<span class="kd">public</span> <span class="nf">Yum</span><span class="o">(</span><span class="nc">Yum</span> <span class="n">yum</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">};</span>

<span class="c1">// 복사 팩터리(conversion factory)</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="nc">Yum</span> <span class="nf">newInstance</span><span class="o">(</span><span class="nc">Yum</span> <span class="n">yum</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">};</span>
</pre></table></code></div></div><h3 id="복사-생성자와-복사-팩터리가-cloneable-clone-방식보다-나은-이유"><span class="mr-2">복사 생성자와 복사 팩터리가 Cloneable /clone 방식보다 나은 이유</span><a href="#복사-생성자와-복사-팩터리가-cloneable-clone-방식보다-나은-이유" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>언어 모순적이고 위험천만한 객체 생성 매니즘(생성자를 쓰지 않는 방식)을 사용하지 않음.<li>정상적인 final 필드 용법과 충돌하지 않음<li>불필요한 검사 예외를 던지지 않고 형변환도 필요 없음<li>해당 클래스가 구현한 인터페이스 타입의 인스턴스도 인수로 받을수 있음.</ul><h3 id="핵심-정리"><span class="mr-2">핵심 정리</span><a href="#핵심-정리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>새로운 인터페이스를 만들 때는 절대 Cloneable을 확장해서는 안되며, 새로운 클래스도 이를 구현해서는 안된다. (final class라면 위험이 크지는 않음)<li>성능 최적화 관점에서 검토한 후 별다른 문제가 없을 때만 드믈게 허용해야 한다.<li>복제 기능은 생성자와 팩토리를 이용하는게 최고이나 배열만은 clone 메서드 방식이 가장 깔끔한, 이 규칙의 합당한 예외</ul><h2 id="item14-comparable을-구현할지-고려하라"><span class="mr-2"><a id="item14">Item14. Comparable을 구현할지 고려하라.</a></span><a href="#item14-comparable을-구현할지-고려하라" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><blockquote><p>Comparable interface의 유일무이한 메서드인 compareTo compareTo는 Object의 메서드가 아님. 위 2가지를 제외하고는 Object의 equals와 같지만, compareTo는 단순 동치성 비교에 더해 순서까지 비교할 수 있으며, 제네릭한 특징을 가진다. Comparable을 구현한다는 것은 그 클래스 인스턴스간에 자연적인 순서(natural order)가 있음을 뜻한다.</p></blockquote><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">pulbic</span> <span class="kd">interface</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
      <span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="comparablecompareto-메서드-일반-규약"><span class="mr-2">Comparable.compareTo 메서드 일반 규약</span><a href="#comparablecompareto-메서드-일반-규약" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>이 객체가 주어진 객체보다 작으면 음의 정수, 같으면 0, 크면 양의 정수 반환(비교불가한 경우 ClassCastException 발생)<li>Comparable을 구현한 클래스는 모든 x,y에 대해 sgn(x.compareTo(y)) == -sgn(y.compareTo(x))여야 한다.<li>추이성을 보장해야 한다. ( x.compareTo(y) &gt; 0 &amp;&amp; y.compareTo(z) &gt; 0 이면 x.compareTo(z) &gt; 0<li>모든 z에 대해 x.compareTo(y) == 0이면 sgn(x.compareTo(z)) == sgn(y.compareTo(z))이다.<li>(x.compareTo(y) ==0) == (x.equals(y)) =&gt; 필수는 아니지만 권고사항</ul><h3 id="정렬된-컬렉션에서의-동치성-비교"><span class="mr-2">정렬된 컬렉션에서의 동치성 비교</span><a href="#정렬된-컬렉션에서의-동치성-비교" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>정렬된 컬렉션들은 일반적으로 equals 대신 compareTo를 사용하여 동치성 검증을 한다.<li>compareTo, equals가 일관되지 않은 BigDecimal 클래스 예제<div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">BigDecimal</span><span class="o">&gt;</span> <span class="n">hashSet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">();</span>
     <span class="nc">TreeSet</span><span class="o">&lt;</span><span class="nc">BigDecimal</span><span class="o">&gt;</span> <span class="n">treeSet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeSet</span><span class="o">&lt;&gt;();</span>

     <span class="nc">BigDecimal</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BigDecimal</span><span class="o">(</span><span class="s">"1.0"</span><span class="o">);</span>
     <span class="nc">BigDecimal</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BigDecimal</span><span class="o">(</span><span class="s">"1.00"</span><span class="o">);</span>

     <span class="n">hashSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
     <span class="n">hashSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>

             <span class="c1">// [1.0, 1.00]</span>
     <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">hashSet</span><span class="o">);</span>

     <span class="n">treeSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
     <span class="n">treeSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>

             <span class="c1">// [1.0]</span>
     <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">treeSet</span><span class="o">);</span>
</pre></table></code></div></div><li>hashSet에서는 equals 메서드로 비교하여 2개의 객체 인스턴스가 다르다고 판단한다.<li>TreeSet에서는 compareTo 메서드로 비교하기 떄문에 BigDecimal 인스턴스를 같다고 판단한다.</ul><h3 id="compareto-작성시-주의사항"><span class="mr-2">compareTo 작성시 주의사항</span><a href="#compareto-작성시-주의사항" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>Comparable은 타입을 인수로 받는 제네릭 인터페이스이므로 compareTo 메서드 인수 타입은 컴파일 타임에 정해진다.(인수 타입 확인 및 형변환 필요 없음)<li>각 필드가 동치인지 비교하는게 아니라 순서를 비교, 객체 참조 필드를 비교하려면 compareTo 메서드를 재귀적으로 호출한다. Comparable을 구현하지 않은 필드나 표준이 아닌 순서로 비교해야 한다면 Comparator을 대신 사용</ul><h3 id="java8-이후의-compare"><span class="mr-2">Java8 이후의 Compare</span><a href="#java8-이후의-compare" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>Comparator 인터페이스가 일련의 비교자 생성 메서드(com-parator construction method)와 팀을 꾸려 메서드 연쇄 방식으로 비교자를 생성할 수 있게 됨.<li>d이 방식이 간결하기는 하나 약간의 성능저하가 뒤따를수 있음.</ul><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="nc">PhoneNumber</span><span class="o">&gt;</span> <span class="no">COMPARATOR</span> <span class="o">=</span>
            <span class="n">comparingInt</span><span class="o">((</span><span class="nc">PhoneNumber</span> <span class="n">pn</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">pn</span><span class="o">.</span><span class="na">areaCode</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">thenComparingInt</span><span class="o">(</span><span class="n">pn</span> <span class="o">-&gt;</span> <span class="n">pn</span><span class="o">.</span><span class="na">prefix</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">thenComparingInt</span><span class="o">(</span><span class="n">pn</span> <span class="o">-&gt;</span> <span class="n">pn</span><span class="o">.</span><span class="na">lineNum</span><span class="o">);</span>

<span class="kd">public</span> <span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="nc">PhoneNumber</span> <span class="n">pn</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="no">COMPARATOR</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">pn</span><span class="o">);</span>
    <span class="o">}</span>
</pre></table></code></div></div><ul><li>comparingInt((PhoneNumber pn) -&gt; pn.areaCode)에서 명시적 Casting한 부분을 주목해보면, 자바의 타입 추론 능력이 이 람다에서 타입을 알아낼만큼 강력하지 않기 때문에 프로그램이 컴파일되도록 명시적 Casting을 처리해준 것.</ul><h3 id="hashcode-값을-기준으로-하는-비교자"><span class="mr-2">hashCode 값을 기준으로 하는 비교자</span><a href="#hashcode-값을-기준으로-하는-비교자" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre> <span class="c1">// 이 방식은 사용해서는 안됨. 정수 오버플로우를 일으키거나 부동수점 계산 방식에 따른 오류를 낼수 있음. ( 추이성 위배)</span>
 <span class="kd">static</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">hashCodeOrder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Comparator</span><span class="o">&lt;&gt;()</span> <span class="o">{</span>
     <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o1</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">o2</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">return</span> <span class="n">o1</span><span class="o">.</span><span class="na">hashCode</span><span class="o">()</span> <span class="o">-</span> <span class="n">o2</span><span class="o">.</span><span class="na">hashCode</span><span class="o">()</span>
     <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 정적 compare 메서드를 활용한 비교자</span>
 <span class="kd">static</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">hashCodeOrder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Comparator</span><span class="o">&lt;&gt;()</span> <span class="o">{</span>
     <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o1</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">o2</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">return</span> <span class="nc">Interger</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="n">o1</span><span class="o">.</span><span class="na">hashCode</span><span class="o">(),</span> <span class="n">o2</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span>
      <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 정적 compare 메서드를 활용한 비교자</span>
 <span class="kd">static</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">hashCodeOrder</span> <span class="o">=</span> <span class="nc">Comparator</span><span class="o">.</span><span class="na">comparingInt</span><span class="o">(</span><span class="n">o</span> <span class="o">-&gt;</span> <span class="n">o</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="핵심정리"><span class="mr-2">핵심정리</span><a href="#핵심정리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>순서를 고려해야 하는 값 클래스를 작성한다면 꼭 Comparable 인터페이스를 구현하여 그 인스턴스들을 쉽게 정렬하고, 검색하고, 비교 기능을 제공하는 컬렉션과 어우러지도록 해야 한다.<li>compareTo 메서드에서 필드의 값을 비교할때는 “&lt;”, “&gt;” 사용하지 말아야 한다.<li>박싱된 기본 타입 클래스에서 제공하는 정적 compare 메서드나 Comparator인터페이스가 제공하는 비교자 생성 메서드를 사용하자</ul><h2 id="추가-코멘트-1"><span class="mr-2">추가 코멘트</span><a href="#추가-코멘트-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>equals, hashCode, Comparable 같은 경우 자바를 이용하는 개발자라면 필수적으로 개념을 확실히 알고 있어야 하지만, 간혹 놓치고 개발하다가 치명적인 버그로 이어지는 경우가 있다. 이런 케이스로 발생하는 버그는 코드를 읽으면서 쉽게 발견되지 않기 때문에 잘 알고 사용하는것이 중요하다.<li>equals, hashCode는 사실상 Lombok같은 라이브러리를 통해서 이용한다면 실수는 거의 없을 것이라고 생각된다.<li>clone은 실제로 직접 개발한 코드에서 정의해서 사용해본 적은 없다. 책에서도 정리된 것처럼 가급적이면 해당 메서드를 구현해야 할 필요성을 못느끼는데 레거시 코드에서 혹시 clone이 정의되어있고, 내가 추가로 개발한 부분이 연관성이 있다면 그떄 관련 개념을 좀 알고 있는것이 도움이 될 것 같다.</ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/devlog/'>DevLog</a>, <a href='/categories/java/'>Java</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/effective-java/" class="post-tag no-text-decoration" >Effective Java</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%20%EC%9E%90%EB%B0%94%203%ED%8C%90%20-%203.%20%EB%AA%A8%EB%93%A0%20%EA%B0%9D%EC%B2%B4%EC%9D%98%20%EA%B3%B5%ED%86%B5%20%EB%A9%94%EC%84%9C%EB%93%9C%20-%20Sungsu's%20Tech%20Blog&url=https%3A%2F%2Fsungsu9022.github.io%2Fposts%2Fdevlog-effective-java-3e-3%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%20%EC%9E%90%EB%B0%94%203%ED%8C%90%20-%203.%20%EB%AA%A8%EB%93%A0%20%EA%B0%9D%EC%B2%B4%EC%9D%98%20%EA%B3%B5%ED%86%B5%20%EB%A9%94%EC%84%9C%EB%93%9C%20-%20Sungsu's%20Tech%20Blog&u=https%3A%2F%2Fsungsu9022.github.io%2Fposts%2Fdevlog-effective-java-3e-3%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fsungsu9022.github.io%2Fposts%2Fdevlog-effective-java-3e-3%2F&text=%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%20%EC%9E%90%EB%B0%94%203%ED%8C%90%20-%203.%20%EB%AA%A8%EB%93%A0%20%EA%B0%9D%EC%B2%B4%EC%9D%98%20%EA%B3%B5%ED%86%B5%20%EB%A9%94%EC%84%9C%EB%93%9C%20-%20Sungsu's%20Tech%20Blog" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/es-bible-4-3/">[엘라스틱서치 바이블] 4. 데이터 다루기 -3(ES Client 라이브러리)</a><li><a href="/posts/es-bible-4-2/">[엘라스틱서치 바이블] 4. 데이터 다루기 -2(집계)</a><li><a href="/posts/es-bible-2/">[엘라스틱서치 바이블] 2. 엘라스틱 서치 기본 동작과 구조</a><li><a href="/posts/es-bible-3-1/">[엘라스틱서치 바이블] 3. 인덱스 설계 - 1</a><li><a href="/posts/spark-guide-6/">[스파크 완벽 가이드] 6. 다양한 데이터 타입 다루기</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/spark/">Spark</a> <a class="post-tag" href="/tags/infra/">Infra</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/kubernetes-in-action/">kubernetes-in-action</a> <a class="post-tag" href="/tags/kubernetes/">kubernetes</a> <a class="post-tag" href="/tags/elasticsearch/">Elasticsearch</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/effective-java/">Effective Java</a> <a class="post-tag" href="/tags/hands-on-reactive-programming-in-spring-5/">Hands-On Reactive Programming in Spring 5</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/devlog-effective-java-3e-2-1/"><div class="card-body"> <em class="small" data-ts="1587746040" data-df="ll" > Apr 25, 2020 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>이펙티브 자바 3판 - 2. 객체 생성과 파괴 - 1</h3><div class="text-muted small"><p> 이펙티브 자바 3판 - 2. 객체 생성과 파괴 - 1 Item1. 생성자 대신 정적 팩터리 메서드를 고려하자. Item2. 생성자에 매개변수가 많다면 빌더를 고려하라 Item3. private 생성자나 열거 타입으로 싱글턴임을 보증하라. Item4. 인스턴스화를 막으려거든 private 생성자를 사용하라. 객체를 만들어야 할 ...</p></div></div></a></div><div class="card"> <a href="/posts/devlog-effective-java-3e-2-2/"><div class="card-body"> <em class="small" data-ts="1588005240" data-df="ll" > Apr 28, 2020 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>이펙티브 자바 3판 - 2. 객체 생성과 파괴 - 2</h3><div class="text-muted small"><p> 이펙티브 자바 3판 - 2. 객체 생성과 파괴 - 2 Item5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라. Item6. 불필요한 객체 생성을 피하라 Item7. 다 쓴 객체 참조를 해제하라 Item8. finalizer 와 cleaner 의 사용을 피하라 Item9. 생성자에 매개변수가 많다면 빌더를 고려하라 It...</p></div></div></a></div><div class="card"> <a href="/posts/devlog-jenv/"><div class="card-body"> <em class="small" data-ts="1590827640" data-df="ll" > May 30, 2020 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>jenv를 활용한 JDK 버전 관리</h3><div class="text-muted small"><p> jenv를 활용한 JDK 버전 관리 jenv란 무엇인가? jenv는 rbenv에서 사용하는 방식을 본떠서 만든 java version 관리 도구입니다. 다양한 버전의 java application 관리 하는 경우에 적절히 손쉽게 version 변경할 수 있습니다. jenv 설치하기 1 brew install jenv sh 설정 추가 ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/devlog-spring-boot-tools/" class="btn btn-outline-primary" prompt="Older"><p>Spring Boot JSP 자동 reload 되지 않는 문제 해결 방법</p></a> <a href="/posts/devlog-jenv/" class="btn btn-outline-primary" prompt="Newer"><p>jenv를 활용한 JDK 버전 관리</p></a></div><div id="disqus_thread" class="pt-2 pb-2"><p class="text-center text-muted small">Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script type="text/javascript"> var disqus_config = function () { this.page.url = 'https://sungsu9022.github.io/posts/devlog-effective-java-3e-3/'; this.page.identifier = '/posts/devlog-effective-java-3e-3/'; }; /* Lazy loading */ var disqus_observer = new IntersectionObserver( function (entries) { if (entries[0].isIntersecting) { (function () { var d = document, s = d.createElement('script'); s.src = 'https://sungsu-parks-tech-blog.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); disqus_observer.disconnect(); } }, { threshold: [0] } ); disqus_observer.observe(document.querySelector('#disqus_thread')); /* Auto switch theme */ function reloadDisqus() { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* Disqus hasn't been loaded */ if (typeof DISQUS === 'undefined') { return; } if (document.readyState == 'complete') { DISQUS.reset({ reload: true, config: disqus_config }); } } } if (document.querySelector('.mode-toggle')) { window.addEventListener('message', reloadDisqus); } </script></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/spark/">Spark</a> <a class="post-tag" href="/tags/infra/">Infra</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/kubernetes-in-action/">kubernetes-in-action</a> <a class="post-tag" href="/tags/kubernetes/">kubernetes</a> <a class="post-tag" href="/tags/elasticsearch/">Elasticsearch</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/effective-java/">Effective Java</a> <a class="post-tag" href="/tags/hands-on-reactive-programming-in-spring-5/">Hands-On Reactive Programming in Spring 5</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://twitter.com/sungsu9022dev">sungsu9022</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0">Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></div></footer><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-145894105-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-145894105-1'); }); </script>
