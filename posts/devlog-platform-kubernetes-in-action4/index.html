<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.3.3" /><meta property="og:title" content="[kubernetes-in-action] 4. 레플리케이션과 그 밖의 컨트롤러 : 관리되는 파드 배포" /><meta name="author" content="sungsu park" /><meta property="og:locale" content="en" /><meta name="description" content="4. 레플리케이션과 그 밖의 컨트롤러 : 관리되는 파드 배포 4.1 파드를 안정적으로 유지하기 쿠버네티스를 사용하면 얻을 수 있는 주요 이점은 쿠버네티스에 컨테이너 목록을 제공하면 해당 컨테이너를 클러스터 어딘가에서 계속 실행되도록 할수 있는 것이다. 파드가 노드에 스케줄링되면 노드의 Kubelet은 이 파드가 존재하는 한 컨테이너가 계속 실행되도록 하고, 컨테이너의 주 프로세스에 크래시가 발생하면 Kubelet이 컨테이너를 다시 시작시킨다. 하지만 JVM 기준으로 OOM이 발생하거나 애플리케이션 무한 루프나 교착상태에 빠져서 응답을 주지 못하는 경우 앱을 재실행하려면 앱 내부의 기능에 의존해서는 안되고, 외부에서 앱의 상태를 체크해야 한다." /><meta property="og:description" content="4. 레플리케이션과 그 밖의 컨트롤러 : 관리되는 파드 배포 4.1 파드를 안정적으로 유지하기 쿠버네티스를 사용하면 얻을 수 있는 주요 이점은 쿠버네티스에 컨테이너 목록을 제공하면 해당 컨테이너를 클러스터 어딘가에서 계속 실행되도록 할수 있는 것이다. 파드가 노드에 스케줄링되면 노드의 Kubelet은 이 파드가 존재하는 한 컨테이너가 계속 실행되도록 하고, 컨테이너의 주 프로세스에 크래시가 발생하면 Kubelet이 컨테이너를 다시 시작시킨다. 하지만 JVM 기준으로 OOM이 발생하거나 애플리케이션 무한 루프나 교착상태에 빠져서 응답을 주지 못하는 경우 앱을 재실행하려면 앱 내부의 기능에 의존해서는 안되고, 외부에서 앱의 상태를 체크해야 한다." /><link rel="canonical" href="https://sungsu9022.github.io/posts/devlog-platform-kubernetes-in-action4/" /><meta property="og:url" content="https://sungsu9022.github.io/posts/devlog-platform-kubernetes-in-action4/" /><meta property="og:site_name" content="Sungsu’s Tech Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-08-07T17:34:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[kubernetes-in-action] 4. 레플리케이션과 그 밖의 컨트롤러 : 관리되는 파드 배포" /><meta name="twitter:site" content="@sungsu9022dev" /><meta name="twitter:creator" content="@sungsu park" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"sungsu park"},"dateModified":"2020-08-07T17:34:00+09:00","datePublished":"2020-08-07T17:34:00+09:00","description":"4. 레플리케이션과 그 밖의 컨트롤러 : 관리되는 파드 배포 4.1 파드를 안정적으로 유지하기 쿠버네티스를 사용하면 얻을 수 있는 주요 이점은 쿠버네티스에 컨테이너 목록을 제공하면 해당 컨테이너를 클러스터 어딘가에서 계속 실행되도록 할수 있는 것이다. 파드가 노드에 스케줄링되면 노드의 Kubelet은 이 파드가 존재하는 한 컨테이너가 계속 실행되도록 하고, 컨테이너의 주 프로세스에 크래시가 발생하면 Kubelet이 컨테이너를 다시 시작시킨다. 하지만 JVM 기준으로 OOM이 발생하거나 애플리케이션 무한 루프나 교착상태에 빠져서 응답을 주지 못하는 경우 앱을 재실행하려면 앱 내부의 기능에 의존해서는 안되고, 외부에서 앱의 상태를 체크해야 한다.","headline":"[kubernetes-in-action] 4. 레플리케이션과 그 밖의 컨트롤러 : 관리되는 파드 배포","mainEntityOfPage":{"@type":"WebPage","@id":"https://sungsu9022.github.io/posts/devlog-platform-kubernetes-in-action4/"},"url":"https://sungsu9022.github.io/posts/devlog-platform-kubernetes-in-action4/"}</script><title>[kubernetes-in-action] 4. 레플리케이션과 그 밖의 컨트롤러 : 관리되는 파드 배포 | Sungsu's Tech Blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Sungsu's Tech Blog"><meta name="application-name" content="Sungsu's Tech Blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/personal/sunny.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">Sungsu's Tech Blog</a></div><div class="site-subtitle font-italic">Java/Kotlin Spring, Back-end</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/sungsu9022" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/sungsu9022dev" aria-label="twitter" target="_blank" rel="noopener noreferrer"> <i class="fab fa-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['sungsu9022','naver.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[kubernetes-in-action] 4. 레플리케이션과 그 밖의 컨트롤러 : 관리되는 파드 배포</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>[kubernetes-in-action] 4. 레플리케이션과 그 밖의 컨트롤러 : 관리되는 파드 배포</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1596789240" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Aug 7, 2020 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href=""></a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="7155 words"> <em>39 min</em> read</span></div></div></div><div class="post-content"><h1 id="4-레플리케이션과-그-밖의-컨트롤러--관리되는-파드-배포">4. 레플리케이션과 그 밖의 컨트롤러 : 관리되는 파드 배포</h1><h2 id="41-파드를-안정적으로-유지하기"><span class="mr-2">4.1 파드를 안정적으로 유지하기</span><a href="#41-파드를-안정적으로-유지하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>쿠버네티스를 사용하면 얻을 수 있는 주요 이점은 쿠버네티스에 컨테이너 목록을 제공하면 해당 컨테이너를 클러스터 어딘가에서 계속 실행되도록 할수 있는 것이다.<li>파드가 노드에 스케줄링되면 노드의 Kubelet은 이 파드가 존재하는 한 컨테이너가 계속 실행되도록 하고, 컨테이너의 주 프로세스에 크래시가 발생하면 Kubelet이 컨테이너를 다시 시작시킨다.<li>하지만 JVM 기준으로 OOM이 발생하거나 애플리케이션 무한 루프나 교착상태에 빠져서 응답을 주지 못하는 경우 앱을 재실행하려면 앱 내부의 기능에 의존해서는 안되고, 외부에서 앱의 상태를 체크해야 한다.</ul><h3 id="411-라이브니스-프로브-liveness-probe"><span class="mr-2">4.1.1. 라이브니스 프로브 (Liveness probe)</span><a href="#411-라이브니스-프로브-liveness-probe" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>쿠버네티스는 라이브니스 프로브를 통해 컨테이너가 살아 있는지 확인할 수 있다.<li>파드의 스펙에 각 컨테이너의 라이브니스 프로브를 지정하면 된다.<li>쿠버네티스는 주기적으로 프로브를 실행하고 프로브가 실패할 경우 컨테이너를 다시 시작한다.</ul><h4 id="쿠버네티스의-프로브-매커니즘"><span class="mr-2">쿠버네티스의 프로브 매커니즘</span><a href="#쿠버네티스의-프로브-매커니즘" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="1-http-get-프로브"><span class="mr-2">1) HTTP GET 프로브</span><a href="#1-http-get-프로브" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><ul><li>지정한 IP, 포트, 경로에 HTTP GET 요청을 수행<li>프로브가 응답을 수신하고 응답코드가 오류가 아닌 경우 성공(2xx, 3xx)<li>오류 응답코드이면 실패로 간주(4xx, 5xx)</ul><h5 id="2-tcp-소켓-프로브"><span class="mr-2">2) TCP 소켓 프로브</span><a href="#2-tcp-소켓-프로브" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><ul><li>컨테이너의 지정된 포트에 TCP 연결을 수행<li>연결이 성공하면 성공, 실패하면 실패</ul><h5 id="3-exec-프로브"><span class="mr-2">3) Exec 프로브</span><a href="#3-exec-프로브" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><ul><li>컨테이너 내의 임의의 명령을 실행하고 명령의 종료 상태 코드 확인<li>상태 코드가 0이면 성공, 다른코드는 모두 실패로 간주</ul><h3 id="412-http-기반-라이브니스-프로브-생성"><span class="mr-2">4.1.2 HTTP 기반 라이브니스 프로브 생성</span><a href="#412-http-기반-라이브니스-프로브-생성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">kubia-liveness</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">containers</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">image</span><span class="pi">:</span> <span class="s">luksa/kubia-unhealthy</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">kubia</span>
    <span class="na">livenessProbe</span><span class="pi">:</span>  <span class="c1"># 라이브니스 프로브 추가</span>
      <span class="na">httpGet</span><span class="pi">:</span>
        <span class="na">path</span><span class="pi">:</span> <span class="s">/</span>            <span class="c1"># HTTP 요청 경로</span>
        <span class="na">port</span><span class="pi">:</span> <span class="m">8080</span>    <span class="c1"># 프로브가 연결해야 하는 포트</span>
</pre></table></code></div></div><h3 id="413-동작중인-라이브니스-프로브-확인"><span class="mr-2">4.1.3 동작중인 라이브니스 프로브 확인</span><a href="#413-동작중인-라이브니스-프로브-확인" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="c"># 라이브니스 프로브 생성</span>
kubectl create <span class="nt">-f</span> kubia-liveness-probe.yaml

<span class="c"># 라이브니스 프로브 확인</span>
kubectl get po kubia-liveness

<span class="c"># 크래시된 컨테이너의 애플리케이션 로그 조회</span>
kubectl logs <span class="o">{</span>podName<span class="o">}</span> <span class="nt">--previous</span>

<span class="c"># pod이 다시 시작되는 이유 확인</span>
kubectl describe po kubia-liveness
</pre></table></code></div></div><h4 id="pod-last-state-exit-code"><span class="mr-2">Pod Last State Exit Code</span><a href="#pod-last-state-exit-code" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>정상적으로 종료된 경우 0<li>외부에 의해서 종료된 경우 128 + x의 값을 가진다.<ul><li>x는 프로세스에 전송된 시그널 번호임. SIGKILL 번호인 9로 강제종료된다면 128+9 = 137이 된다.</ul></ul><h3 id="414-라이브니스-프로브의-추가-속성-설정"><span class="mr-2">4.1.4 라이브니스 프로브의 추가 속성 설정</span><a href="#414-라이브니스-프로브의-추가-속성-설정" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="kubectl-describe을-통해-라이브니스-추가-정보를-확인할-수-있다"><span class="mr-2">kubectl describe을 통해 라이브니스 추가 정보를 확인할 수 있다.</span><a href="#kubectl-describe을-통해-라이브니스-추가-정보를-확인할-수-있다" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="na">Liveness </span><span class="pi">:</span> <span class="s">http-get http://:8080/ delay=0s timeout=1s period=10s</span> <span class="c1">#success=1 #failure=3</span>
</pre></table></code></div></div><ul><li>delay(지연) - 컨테이너가 시작된 후 바로 프로브 시작된다.<li>timeout(제한시간) - 컨테이너가 제한시간 안에 응답이 와야 한다.<li>period(기간) - 기간마다 프로브를 수행한다<li>#failure(실패수) - n번 연속 실패시 컨테이너가 다시 시작한다.</ul><h4 id="설정-정의"><span class="mr-2">설정 정의</span><a href="#설정-정의" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>initialDelaySeconds 옵션을 정의하여 설정할 수 있다.</ul><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">kubia-liveness</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">containers</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">image</span><span class="pi">:</span> <span class="s">luksa/kubia-unhealthy</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">kubia</span>
    <span class="na">livenessProbe</span><span class="pi">:</span>
      <span class="na">httpGet</span><span class="pi">:</span>
        <span class="na">path</span><span class="pi">:</span> <span class="s">/</span>
        <span class="na">port</span><span class="pi">:</span> <span class="m">8080</span>
      <span class="na">initialDelaySeconds</span><span class="pi">:</span> <span class="m">15</span>
</pre></table></code></div></div><h4 id="라이브니스-프로브-정의시-주의사항"><span class="mr-2">라이브니스 프로브 정의시 주의사항</span><a href="#라이브니스-프로브-정의시-주의사항" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>애플리케이션 시작시간을 고려해서 초기 지연을 설정해야 한다.</ul><h3 id="415-효과적인-라이브니스-프로브-생성"><span class="mr-2">4.1.5 효과적인 라이브니스 프로브 생성</span><a href="#415-효과적인-라이브니스-프로브-생성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>운영환경이라면 반드시 라이브니스 프로브를 정의하는 것이 좋다.(L7 health check 같은 느낌으로)<li>정의하지 않으면 쿠버네티스가 앱이 살아 있는지 알 수 있는 방법이 없음.(프로세스가 떠있더라도 실제 문제 상황이 있을 수 있기 때문)</ul><h4 id="라이브니스-프로브가-확인해야-할-사항"><span class="mr-2">라이브니스 프로브가 확인해야 할 사항</span><a href="#라이브니스-프로브가-확인해야-할-사항" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>URL에 요청하도록 프로브를 구성해 앱 내 실행중인 모든 주요 구성요소가 살아있는지 또는 응답이 없는지 확인하도록 구성할 수도 있다.<ul><li>특정 가벼운 API를 호출해본다던지 별도의 헬스체크 URL을 백엔드 엔드포인트로 구성한다던지</ul><li>라이브니스 프로브는 앱 내부만 체크하고 외부 요인의 영향을 받지 않도록 구성해야 한다.<ul><li>예를 들면 DB 서버에 문제가 있는 경우 이 프로브가 실패하도록 구성하는것은 지양해야 한다. 그 이유는 근본적인 원인이 DB라면 앱 컨테이너를 재시작한다 하더라도 문제가 해결되지 않기 때문이다.</ul></ul><h4 id="프로브를-가볍게-유지하기"><span class="mr-2">프로브를 가볍게 유지하기</span><a href="#프로브를-가볍게-유지하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>기본적으로 프로브는 비교적 자주 실행되며 1초 내에 완료되어야 한다.<li>너무 많은 일을 하는 프로브는 컨테이너 속도를 저하 시킬수 있다.<li>컨테이너에서 JVM 과 같은 기동 절차에 상당한 연산 리소스가 필요한 경우 Exec 프로브보다는 HTTP GET 라이브니스 프로브가 적합하다.</ul><h4 id="프로브에-재시도-루프를-구현하지-마라"><span class="mr-2">프로브에 재시도 루프를 구현하지 마라.</span><a href="#프로브에-재시도-루프를-구현하지-마라" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>프로브의 실패 임계값을 설정할수 있기도 하고, 실패 임계값이 1이더라도 쿠버네티스는 실패를 한번 했다고 간주하기 전에 여러번 재시도를 한다.<li>따라서 자체적인 재시도 루프를 구현하지 말아야 한다.</ul><h4 id="라이브니스-프로브-요약"><span class="mr-2">라이브니스 프로브 요약</span><a href="#라이브니스-프로브-요약" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>라이브니스 프로브에 대한 로직은 해당 워커 노드의 Kubelet에서 수행이 된다.<li>만약 워커 노드 자체에 크래시가 발생한 경우 해당 노드의 중단된 모든 파드의 대체 파드를 생성해야 하는것은 컨트롤 플레인의 역할<li>레플리케이션컨트롤러같은 리소스 외에 직접 생선한 Pod들은 워커 노드 자체가 고장나면 아무것도 할 수 없음.</ul><h2 id="42-레플리케이션-컨트롤러-소개"><span class="mr-2">4.2 레플리케이션 컨트롤러 소개</span><a href="#42-레플리케이션-컨트롤러-소개" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>레플리케이션 컨트롤러는 파드가 항상 실행되도록 보장하는 쿠버네티스 리소스이다.<li>파드의 여러 복제본(레플리카)을 작성하고 관리하기 위한 리소스이다.</ul><h3 id="동작-원리"><span class="mr-2">동작 원리</span><a href="#동작-원리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>노드1의 파드 A는 종료된 이후 레플리케이션 컨트롤러가 관리하지 않기 때문에 다시 생성되지 않는다.<li>레플리케이션컨트롤러는 파드B가 사라진것을 인지하고 새로운 파드 인스턴스를 생성한다.</ul><p><a href="https://user-images.githubusercontent.com/6982740/89425688-43afe300-d774-11ea-8bc6-071256ac3164.png" class="popup img-link "><img width="692" alt="스크린샷 2020-08-05 오후 11 34 46" data-src="https://user-images.githubusercontent.com/6982740/89425688-43afe300-d774-11ea-8bc6-071256ac3164.png" class="lazyload" data-proofer-ignore></a></p><h3 id="421-레플리케이션컨트롤러의-동작"><span class="mr-2">4.2.1 레플리케이션컨트롤러의 동작</span><a href="#421-레플리케이션컨트롤러의-동작" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>실행중인 파드 목록을 지속적으로 모니터링하고, 특정 유형의 실제 파드 수가 의도하는 수와 일치하는지 항상 확인한다.</ul><h4 id="의도하는-수의-복제본수가-변경되는-케이스"><span class="mr-2">의도하는 수의 복제본수가 변경되는 케이스</span><a href="#의도하는-수의-복제본수가-변경되는-케이스" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><blockquote><p>파드 유형이란 특정 레비을 셀렉터와 일치하는 파드 세트(실제로 유형이라는 개념은 특별히 없다.)</p><ul><li>누군가 같은 유형의 파드를 수동으로 만드는 경우<li>누군가 기존 파드의 유형을 변경하는 경우<li>누군가 의도하는 파드 수를 줄이는 경우</ul></blockquote><h4 id="컨트롤러-조정-루프"><span class="mr-2">컨트롤러 조정 루프</span><a href="#컨트롤러-조정-루프" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>레플리케이션컨트롤러의 역할은 정확한 수의 파드가 항상 레이블 셀렉터와 일치하는지 확인하는 것이다.</ul><p><a href="https://user-images.githubusercontent.com/6982740/89426209-dea8bd00-d774-11ea-9f71-601232939e9c.png" class="popup img-link "><img width="555" alt="스크린샷 2020-08-05 오후 11 39 06" data-src="https://user-images.githubusercontent.com/6982740/89426209-dea8bd00-d774-11ea-9f71-601232939e9c.png" class="lazyload" data-proofer-ignore></a></p><h4 id="레플리케이션컨트롤러의-3가지-요소"><span class="mr-2">레플리케이션컨트롤러의 3가지 요소</span><a href="#레플리케이션컨트롤러의-3가지-요소" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>레이블 셀렉터는 범위에 있는 파드를 결정<li>레플리카수는 실행할 파드의 의도하는 수를 지정<li>파드 템플릿은 새로운 파드 레플리카 만들때 사용(파드 정의)</ul><h4 id="컨트롤러의-레이블-셀렉터-또는-파드-템플릿-변경의-영향-이해"><span class="mr-2">컨트롤러의 레이블 셀렉터 또는 파드 템플릿 변경의 영향 이해</span><a href="#컨트롤러의-레이블-셀렉터-또는-파드-템플릿-변경의-영향-이해" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>레이블 셀렉터와 파드 템플릿을 변경하더라도 기존 파드에는 영향을 미치지 않음.<li>레플리케이션컨트롤러는 파드를 생성한 후에는 실제 컨텐츠(컨테이너 이미지, 환경변수 등)에 신경 쓰지 않음.<li>그래서 변경 이후에 새 파드가 생성되는 시점에서만 영향을 미친다.</ul><h4 id="레플리케이션컨트롤러-사용시-이점"><span class="mr-2">레플리케이션컨트롤러 사용시 이점</span><a href="#레플리케이션컨트롤러-사용시-이점" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>기존 파드가 사라지면 새 파드를 시작해 파드가 항상 실행되도록 보장할 수 있다.<li>클러스터 노드에 장애가 발생하면 장애가 발생한 노드에서 실행중인 모든 파드에 관한 교체 복제본이 생성된다.<li>수동 또는 자동으로 파드를 쉽게 수평 확장할수 있다.</ul><h3 id="422-레플리케이션컨트롤러-생성"><span class="mr-2">4.2.2 레플리케이션컨트롤러 생성</span><a href="#422-레플리케이션컨트롤러-생성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">ReplicationController</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">kubia</span>        <span class="c1"># 레플리케이션컨트롤러 이름</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">replicas</span><span class="pi">:</span> <span class="m">3</span>           <span class="c1"># 의도한 파드 인스턴스 수</span>
  <span class="na">selector</span><span class="pi">:</span>             <span class="c1"># 관리하는 파드 셀렉터</span>
    <span class="na">app</span><span class="pi">:</span> <span class="s">kubia</span>
  <span class="na">template</span><span class="pi">:</span>              <span class="c1"># 파드 템플릿</span>
    <span class="na">metadata</span><span class="pi">:</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="na">app</span><span class="pi">:</span> <span class="s">kubia</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">containers</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">kubia</span>
        <span class="na">image</span><span class="pi">:</span> <span class="s">luksa/kubia</span>
        <span class="na">ports</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">containerPort</span><span class="pi">:</span> <span class="m">8080</span>
</pre></table></code></div></div><ul><li>레플리케이션 spec.selector를 지정하지 않을 수도 있다.(Optional)<li>셀렉터를 지정하지 않으면 템플릿의 레이블로 자동 설정된다.<li>레플리케이션컨트롤러를 정의할 때 셀렉터를 지정하지 않는것이 좋다.(쿠버네티스가 자동으로 추출하도록 하는게 간결하고 더 단순하다)</ul><h4 id="레플리케이션-컨트롤러-생성"><span class="mr-2">레플리케이션 컨트롤러 생성</span><a href="#레플리케이션-컨트롤러-생성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>kubectl create <span class="nt">-f</span> kubia-rc.yaml
</pre></table></code></div></div><h3 id="423-레플리케이션-컨트롤러-동작-확인"><span class="mr-2">4.2.3 레플리케이션 컨트롤러 동작 확인</span><a href="#423-레플리케이션-컨트롤러-동작-확인" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>kubectl get pods
</pre></table></code></div></div><h4 id="삭제된-파드에-관한-레플리케이션-컨트롤러의-반응"><span class="mr-2">삭제된 파드에 관한 레플리케이션 컨트롤러의 반응</span><a href="#삭제된-파드에-관한-레플리케이션-컨트롤러의-반응" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="c"># 삭제</span>
kubectl delete pod kubia-2lqjr

<span class="c"># 삭제된 팟 확인</span>
kubectl get pods

<span class="c"># 레플리케이션 정보 확인</span>
kubectl get rc

<span class="c"># 레플리케이션컨트롤러 추가 정보 확인</span>
kubectl describe rc kubia
</pre></table></code></div></div><h4 id="컨트롤러가-새로운-파드를-생성한-원인-정확히-이해하기"><span class="mr-2">컨트롤러가 새로운 파드를 생성한 원인 정확히 이해하기</span><a href="#컨트롤러가-새로운-파드를-생성한-원인-정확히-이해하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>레플레키에션컨트롤러가 삭제 액션에 반응한 것이 아니다.<li>결과적인 상태(부족한 파드수)에 대응한 것을 알아야 한다.<li>파드 삭제가 일어난 이후 컨트롤러의 실제 파드 수 확인하였고, 이에 대한 적절한 조치로 새로운 파드가 생성된 것</ul><p><a href="https://user-images.githubusercontent.com/6982740/89428005-dc476280-d776-11ea-9724-d8e7e63ffdb4.png" class="popup img-link "><img width="700" alt="스크린샷 2020-08-05 오후 11 53 24" data-src="https://user-images.githubusercontent.com/6982740/89428005-dc476280-d776-11ea-9724-d8e7e63ffdb4.png" class="lazyload" data-proofer-ignore></a></p><h4 id="노드-장애-대응"><span class="mr-2">노드 장애 대응</span><a href="#노드-장애-대응" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>쿠버네티스를 사용하지 않는 환경에서 노드에 장애가 발생하면 앱을 수동으로 다른 시스템에 마이그레이션해야 함.(매우 오랜 시간이 걸리고 큰 문제)<li>레플리케이션컨트롤러는 노드의 다운을 감지하자마자 파드를 대체하기 위해 새 파드를 기동시킨다.</ul><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>
<span class="c"># 노드의 eth0 을 다운시킨 후 노드 확인</span>
<span class="c"># 이 경우 해당 노드는 NotReady 상태로 변경된다.</span>
kubectl get node


<span class="c"># 파드 확인</span>
<span class="c"># NotReady 상태의 노드에 있던 Pod는 Unknown 상태로 변경되고 삭제된다.(새로운 파드가 다른 노드에서 생성됨)</span>
kubectl get pods
</pre></table></code></div></div><h3 id="424-레플리케이션컨트롤러-범위-안팎으로-파드-이동하기"><span class="mr-2">4.2.4 레플리케이션컨트롤러 범위 안팎으로 파드 이동하기</span><a href="#424-레플리케이션컨트롤러-범위-안팎으로-파드-이동하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>레플리케이션컨트롤러는 레이블 셀렉터와 일치하는 파드만을 관리한다.<li>파드의 레이블을 변경하면 범위에서 제거되거나 추가시킬 수 있다.<li>파드는 metadata.ownerReferences 필드에서 레플리케이션컨트롤러 참조 정보를 확인할 수 있다.<li>파드의 레이블을 변경하여 범위에서 제거하면 수동으로 만든 다른 파드처럼 변경된다.</ul><h4 id="레플리케이션-컨트롤러가-관리하는-파드에-레이블-추가"><span class="mr-2">레플리케이션 컨트롤러가 관리하는 파드에 레이블 추가</span><a href="#레플리케이션-컨트롤러가-관리하는-파드에-레이블-추가" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>관리하지 않는 레이블이라면 아무런 영향이 없다.</ul><h4 id="관리되는-파드의-레이블-변경"><span class="mr-2">관리되는 파드의 레이블 변경</span><a href="#관리되는-파드의-레이블-변경" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>레플리케이션컨트롤러에서 관리하지 않는 레이블로 변경하게 되면 범위에서 제거된것으로 간주하고 레플리케이션컨트롤러는 새로운 파드를 생성한다.</ul><h4 id="컨트롤러에서-파드를-제거하는-실제-사례"><span class="mr-2">컨트롤러에서 파드를 제거하는 실제 사례</span><a href="#컨트롤러에서-파드를-제거하는-실제-사례" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>특정 파드에서만 어떤 작업을 하려는 경우 레이블을 변경하여 범위에서 제거하면 작업이 수월해질 수 있다.<li>오동작하는 파드가 하나 있을때 이를 범위 밖으로 빼내고(이때 레플리케이션컨트롤러에 의해 레플리카수는 유지될것이다.) 원하는 방식으로 파드를 디버그하거나 문제를 재연해볼 수 있다.</ul><h4 id="레플리케이션컨트롤러의-레이블-셀렉터-변경"><span class="mr-2">레플리케이션컨트롤러의 레이블 셀렉터 변경</span><a href="#레플리케이션컨트롤러의-레이블-셀렉터-변경" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>컨트롤러의 레이블을 변경하면 모든 파드들이 범위를 벗어나게 되므로 새로운 N개의 파드를 생성하게 된다.</ul><h3 id="425-파드-템플릿-변경"><span class="mr-2">4.2.5 파드 템플릿 변경</span><a href="#425-파드-템플릿-변경" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>템플릿을 변경하는것은 쿠키 커터를 다른것으로 교체하는 것과 같다.<li>나중에 잘라낼 쿠키에만 영향을 줄뿐 이미 잘라낸 쿠키에는 아무런 영향을 미치지 않는다.</ul><h4 id="템플릿을-수정하는-방법"><span class="mr-2">템플릿을 수정하는 방법</span><a href="#템플릿을-수정하는-방법" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>kubectl edit rc kubia
</pre></table></code></div></div><ul><li>기본 텍스트 편집기에서 레플리케이션컨트롤러의 YMAL 정의가 열려서 이를 수정할 수 있다.<li>KUBE_EDITOR 환경변수를 설정해서 텍스트 편집기를 커스텀할 수 있다.</ul><h3 id="426-수평-파드-스케일링"><span class="mr-2">4.2.6 수평 파드 스케일링</span><a href="#426-수평-파드-스케일링" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="레플리케이션컨트롤러-스케일-업확장--스케일-다운축소"><span class="mr-2">레플리케이션컨트롤러 스케일 업(확장) / 스케일 다운(축소)</span><a href="#레플리케이션컨트롤러-스케일-업확장--스케일-다운축소" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="c"># 확대</span>
kubectl scale rc kubia <span class="nt">--replicas</span><span class="o">=</span>10

<span class="c"># 조회</span>
kubectl get rc

<span class="c"># 축소</span>
kubectl scale rc kubia <span class="nt">--replicas</span><span class="o">=</span>3
</pre></table></code></div></div><ul><li>위와 같이 수정을 하게 되면 레플리케이션컨트롤러가 업데이트되고 즉시 파드 수가 10개로 확장되었다가 다시 3개로 축소된다.</ul><h4 id="스케일링에-대한-선언적-접근-방법-이해"><span class="mr-2">스케일링에 대한 선언적 접근 방법 이해</span><a href="#스케일링에-대한-선언적-접근-방법-이해" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>쿠버네티스에게 무엇을 어떻게 하라고 말하는게 아니라 의도하는 상태로 변경하는 것뿐.<li>쿠버네티스는 상태를 보고 상태에 맞게 조정한다.</ul><h3 id="427-레플리케이션컨트롤러-삭제"><span class="mr-2">4.2.7 레플리케이션컨트롤러 삭제</span><a href="#427-레플리케이션컨트롤러-삭제" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>kubectl delete를 통해 컨트롤러를 삭제하면 파드도 같이 삭제된다.</ul><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c"># 파드와 컨트롤러 모두 삭제</span>
kubectl delete rc kubia

<span class="c"># 파드를 삭제하지 않고 레플리케이션 컨트롤러를 삭제하는 방법</span>
kubectl delete rc kubia <span class="nt">--cascade</span><span class="o">=</span><span class="nb">false</span>
</pre></table></code></div></div><h2 id="43-레플리카셋"><span class="mr-2">4.3 레플리카셋</span><a href="#43-레플리카셋" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>레플리카셋은 레플리케이션컨트롤러와 유사한 리소스이고 레플리케이션컨트롤러를 대체하기 위한 나온 리소스이다.<li>일반적으로는 레플리카셋을 직접 생성하지는 않고 상위 수준의 디플로이먼트 리소스를 생성하면 자동으로 생성된다.</ul><h3 id="431-레플리카셋과-레플리케이션컨트롤러-비교"><span class="mr-2">4.3.1 레플리카셋과 레플리케이션컨트롤러 비교</span><a href="#431-레플리카셋과-레플리케이션컨트롤러-비교" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>레플리카셋이 좀 더 풍부한 파드 셀렉터 표현식을 사용할 수 있다.<ul><li>특정 레이블이 없는 파드나 레이블의 값과 상관없이 특정 레이블의 키를 갖는 파드를 매칭시킬 수도 있다.<li>또한 하나의 레플리카셋으로 두 파드 세트를 모두 매칭시켜 하나의 그룹으로 취급하는것도 가능하다.</ul><li>위 부분을 제외하고는 다르지 않음.</ul><h3 id="432-레플리카셋-정의하기"><span class="mr-2">4.3.2 레플리카셋 정의하기</span><a href="#432-레플리카셋-정의하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">ReplicaSet</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">kubia</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">replicas</span><span class="pi">:</span> <span class="m">3</span>
  <span class="na">selector</span><span class="pi">:</span>
<span class="c1">#    matchLabels:</span>
<span class="c1">#      app: kubia</span>
    <span class="na">matchExpressions</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">key</span><span class="pi">:</span> <span class="s">app</span>
        <span class="na">operator</span><span class="pi">:</span> <span class="s">In</span>
        <span class="na">values</span><span class="pi">:</span>
         <span class="pi">-</span> <span class="s">kubia</span>
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">metadata</span><span class="pi">:</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="na">app</span><span class="pi">:</span> <span class="s">kubia</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">containers</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">kubia</span>
        <span class="na">image</span><span class="pi">:</span> <span class="s">luksa/kubia</span>
</pre></table></code></div></div><h4 id="api-버전-속성"><span class="mr-2">API 버전 속성</span><a href="#api-버전-속성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>API 그룹, API 버전으로 구분되며 “apps/v1bet2”인 경우 그룹은 apps, 버전은 v1beta2이다.<li>core API 그룹에 속할 경우에는 그룹을 명시하지 않아도 된다. (v1)</ul><h3 id="433-레플리카셋-생성-및-검사"><span class="mr-2">4.3.3. 레플리카셋 생성 및 검사</span><a href="#433-레플리카셋-생성-및-검사" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>레플리카셋 생성은 api v1으로만 해야한다.(버전업되면서 변경됨)</ul><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c"># 레플리카셋 생성</span>
kubectl create <span class="nt">-f</span> kubia-replicaset.yaml

<span class="c"># 레플리카셋 조회</span>
kubectl get rs
</pre></table></code></div></div><h3 id="434-레플리카셋의-더욱-표현적인-레이블-셀렉터"><span class="mr-2">4.3.4 레플리카셋의 더욱 표현적인 레이블 셀렉터</span><a href="#434-레플리카셋의-더욱-표현적인-레이블-셀렉터" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>In은 레이블의 값이 지정된 값 중 하나와 일치해야 함.<li>NotIn은 레이블의 값이 지정된 값과 일치하지 않아야 함.<li>Exists는 파드의 지정된 키를 가진 레이블이 포함되어야 한다.(값은 관계없기에 value 필드를 지정하지 않는다.)<li>DoesNotExists는 파드에 지정된 키를 가진 레이블이 포함돼 있지 않아야 한다.(value 지정 X)</ul><h3 id="435-레플리카셋-삭제"><span class="mr-2">4.3.5 레플리카셋 삭제</span><a href="#435-레플리카셋-삭제" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>kubectl delete rs kubia
</pre></table></code></div></div><h2 id="44-데몬셋"><span class="mr-2">4.4. 데몬셋</span><a href="#44-데몬셋" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>데몬셋을 사용하면 각 노드에서 정확히 한 개의 파드만 실행시킬 수 있다.<li>레플리카셋은 노드는 관계없이 지정된 수만큼 파드를 실행하는데 데몬셋은 이런 수를 지정하는것이 없고 클러스터의 모든 노드에 노드당 하나의 파드만 실행시키는 리소스이다.<li>시스템 수준의 작업을 수행하는 인프라 관련 파드가 있다고 하면 데몬셋이 가장 적합할것이다.<li>다른 예는 kube-proxy 프로세스가 데몬셋의 예이다. 서비스를 작동시키기 위해 모든 노드에서 실행되어야 하기 때문이다.</ul><h3 id="441-데몬셋으로-모든-노드에-파드-실행하기"><span class="mr-2">4.4.1 데몬셋으로 모든 노드에 파드 실행하기</span><a href="#441-데몬셋으로-모든-노드에-파드-실행하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>모든 클러스 노드마다 파드를 하나만 실행하고자 할때 사용하면 되는 리소스이다.<li>만약 하나의 노드가 다운되더라도 다른곳에서 파드를 생성하지 않고, 새로운 노드가 클러스터에 추가되면 즉시 새 파드 인스턴스를 해당 노드에 배포한다.</ul><p><a href="https://user-images.githubusercontent.com/6982740/89438132-672e5a00-d783-11ea-8d67-1ed2a7e3025c.png" class="popup img-link "><img width="574" alt="스크린샷 2020-08-06 오전 1 23 08" data-src="https://user-images.githubusercontent.com/6982740/89438132-672e5a00-d783-11ea-8d67-1ed2a7e3025c.png" class="lazyload" data-proofer-ignore></a></p><h3 id="442-데몬셋을-사용해-특정-노드에서만-파드-실행하기"><span class="mr-2">4.4.2 데몬셋을 사용해 특정 노드에서만 파드 실행하기</span><a href="#442-데몬셋을-사용해-특정-노드에서만-파드-실행하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>파드가 노드의 일부에서만 실행되도록 지정하지 않으면 데몬셋은 클러스터 모든 노드에 파드를 배포한다.<li>하지만 파드 템플릿에서 node-Selector 속성을 지정하면 특정 노드에만 배포할 수 있다.</ul><h4 id="데몬셋과-파드-스케줄링"><span class="mr-2">데몬셋과 파드 스케줄링</span><a href="#데몬셋과-파드-스케줄링" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>쿠버네티스를 이용하면 노드에 스케줄링 되지 않게 해서 파드가 노드에 배포되지 않도록 할수도 있는데 이는 스케줄링 기반으로 동작하는 처리방식이다.<li>데몬셋이 관리하는 파드의 경우는 스케줄러와는 무관하기 때문에 스케줄링이 되지 않는 노드에서도 파드가 실행된다.</ul><h4 id="데몬셋-적용-예제"><span class="mr-2">데몬셋 적용 예제</span><a href="#데몬셋-적용-예제" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>노드에 레레이블을 지정하여 노드2를 제외한곳에만 데몬셋 파드가 실행되도록 처리한 예제이다.</ul><p><a href="https://user-images.githubusercontent.com/6982740/89438586-f8053580-d783-11ea-982d-442f5f209826.png" class="popup img-link "><img width="595" alt="스크린샷 2020-08-06 오전 1 27 12" data-src="https://user-images.githubusercontent.com/6982740/89438586-f8053580-d783-11ea-982d-442f5f209826.png" class="lazyload" data-proofer-ignore></a></p><h4 id="데몬셋-yaml-정의"><span class="mr-2">데몬셋 YAML 정의</span><a href="#데몬셋-yaml-정의" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>apiVerison이 쿠버네티스 업데이트 따라 변경되어서 “apps/v1” 을 이용해야 함.</ul><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">apps/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">DaemonSet</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">ssd-monitor</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">matchLabels</span><span class="pi">:</span>
      <span class="na">app</span><span class="pi">:</span> <span class="s">ssd-monitor</span>
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">metadata</span><span class="pi">:</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="na">app</span><span class="pi">:</span> <span class="s">ssd-monitor</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">nodeSelector</span><span class="pi">:</span>
        <span class="na">disk</span><span class="pi">:</span> <span class="s">ssd</span>
      <span class="na">containers</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">main</span>
        <span class="na">image</span><span class="pi">:</span> <span class="s">luksa/ssd-monitor</span>
</pre></table></code></div></div><h4 id="데몬셋-생성"><span class="mr-2">데몬셋 생성</span><a href="#데몬셋-생성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c"># 데몬셋 생성</span>
kubectl create <span class="nt">-f</span> ssd-monitor-daemonset.yaml

<span class="c"># 데몬셋 조회</span>
kubectl get ds
</pre></table></code></div></div><h4 id="노드-레이블-추가-및-삭제"><span class="mr-2">노드 레이블 추가 및 삭제</span><a href="#노드-레이블-추가-및-삭제" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="c"># ssd 레이블 노드에 추가</span>
kubectl label node minikube <span class="nv">disk</span><span class="o">=</span>ssd

<span class="c"># 데몬셋 pod 조회(추가됨)</span>
kubectl get po

<span class="c"># ssd 레이블 노드를 hdd로 변경</span>
kubectl label node minikube <span class="nv">disk</span><span class="o">=</span>hdd <span class="nt">--overwrite</span>

<span class="c"># 데몬셋 pod 조회(제거됨)</span>
kubectl get po
</pre></table></code></div></div><h2 id="45-job-리소스"><span class="mr-2">4.5 Job 리소스</span><a href="#45-job-리소스" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>완료 가능한 단일 태스크를 수행하는 파드를 실행하기 위한 리소스로 Job이 있다.<li>완료 가능한 단일 태스크에서는 프로세스가 종료된 후에 다시 시작되지 않는다.</ul><h3 id="451-job리소스-특징"><span class="mr-2">4.5.1 Job리소스 특징</span><a href="#451-job리소스-특징" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>다른 리소스와 유사하지만 잡은 파드의 컨테이너 내부에서 실행중인 프로세스가 성공적으로 완료되면 컨테이너를 다시 시작하지 않는 파드를 실행시킬 수 있다.<li>작업이 재대로 완료되는 것이 중요한 임시 작업에 유용하다.<li>이러한 잡 리소스에 정의하기에 좋은 예로는 데이터를 어딘가에 저장하고 있고, 이 데이터를 변환해서 어딘가로 전송하는 케이스를 들수 있다.<li>잡에서 과관리하느 파드는 성공적으로 끝날 때까지 다시 스케줄링이 된다.</ul><p><a href="https://user-images.githubusercontent.com/6982740/89439643-71e9ee80-d785-11ea-9aa3-2e2ba26e74d9.png" class="popup img-link "><img width="666" alt="스크린샷 2020-08-06 오전 1 37 47" data-src="https://user-images.githubusercontent.com/6982740/89439643-71e9ee80-d785-11ea-9aa3-2e2ba26e74d9.png" class="lazyload" data-proofer-ignore></a></p><h3 id="452-잡-리소스-정의"><span class="mr-2">4.5.2 잡 리소스 정의</span><a href="#452-잡-리소스-정의" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">batch/v1</span>       <span class="c1"># batchAPI그룹의 버전을 선택해야 한다.</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Job</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">batch-job</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">metadata</span><span class="pi">:</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="na">app</span><span class="pi">:</span> <span class="s">batch-job</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">restartPolicy</span><span class="pi">:</span> <span class="s">OnFailure</span>      <span class="c1"># 재시작 정책을 사용할 수 있음.(Always, OnFailure, Naver)</span>
      <span class="na">containers</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">main</span>
        <span class="na">image</span><span class="pi">:</span> <span class="s">luksa/batch-job</span>
</pre></table></code></div></div><h3 id="453-파드를-실행한-잡-확인"><span class="mr-2">4.5.3 파드를 실행한 잡 확인</span><a href="#453-파드를-실행한-잡-확인" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="c"># Job 생성</span>
kubectl create <span class="nt">-f</span> batch-job.yaml

<span class="c"># Job 확인</span>
kubectl get jods

<span class="c"># Job pod 확인 (completed된 job도 표시됨)</span>
kubectl get po

<span class="c"># 로그 확인</span>
kubectl logs batch-job-9dhsc

<span class="c"># job 삭제(job을 삭제하면 pod도 삭제된다)</span>
kubectl delete job batch-job
</pre></table></code></div></div><h4 id="완료된-파드를-삭제하지-않는-이유"><span class="mr-2">완료된 파드를 삭제하지 않는 이유</span><a href="#완료된-파드를-삭제하지-않는-이유" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>파드가 완료될 때 파드가 삭제되지 않는 이유는 해당 파드의 로그를 검사할 수 있도록 하기 위함이다.</ul><h3 id="454-잡에서-여러-파드-인스턴스-실행하기"><span class="mr-2">4.5.4 잡에서 여러 파드 인스턴스 실행하기</span><a href="#454-잡에서-여러-파드-인스턴스-실행하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>2개 이상의 파드 인스턴스를 생성해 병렬 또는 순차 처리를 구성할 수 있다.(completions, parallelism 속성 이용)</ul><h4 id="순차적으로-잡-파드-실행하기"><span class="mr-2">순차적으로 잡 파드 실행하기</span><a href="#순차적으로-잡-파드-실행하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>spec에 completions값 지정<li>이렇게 처리하면 5개의 파드가 성공적으로 완료될 때까지 과정을 계속한다.<li>중간에 실패하는 파드가 있다면 잡은 새 파드를 생성하여 실제 5개 이상의 파드가 생성될 수 있다.</ul><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">batch/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Job</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">multi-completion-batch-job</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">completions</span><span class="pi">:</span> <span class="m">5</span>
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">metadata</span><span class="pi">:</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="na">app</span><span class="pi">:</span> <span class="s">batch-job</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">restartPolicy</span><span class="pi">:</span> <span class="s">OnFailure</span>
      <span class="na">containers</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">main</span>
        <span class="na">image</span><span class="pi">:</span> <span class="s">luksa/batch-job</span>
</pre></table></code></div></div><h4 id="병렬로-잡-파드-실행하기"><span class="mr-2">병렬로 잡 파드 실행하기</span><a href="#병렬로-잡-파드-실행하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>parallelism을 2로 설정하면 동시에 2개의 파드가 생성되어 병렬처리로 실행된다.</ul><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre>apiVersion: batch/v1
kind: Job
metadata:
  name: multi-completion-batch-job
spec:
  completions: 5
  parallelism: 2
  template:
    metadata:
      labels:
        app: batch-job
    spec:
      restartPolicy: OnFailure
      containers:
      - name: main
        image: luksa/batch-job
</pre></table></code></div></div><h4 id="잡-스케일링"><span class="mr-2">잡 스케일링</span><a href="#잡-스케일링" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>잡이 실행되는 동안 parallelism 속성을 변경하면 동시에 처리되는 파드 수를 조절할 수 있다.<div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>kubectl scale job multi-completion-batch-job <span class="nt">--replicas</span> 3
</pre></table></code></div></div></ul><h3 id="455-잡-파드가-완료되는데-걸리는-시간-제한하기-및-재시도-횟수-설정"><span class="mr-2">4.5.5 잡 파드가 완료되는데 걸리는 시간 제한하기 및 재시도 횟수 설정</span><a href="#455-잡-파드가-완료되는데-걸리는-시간-제한하기-및-재시도-횟수-설정" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>activeDeadlineSeconds 속성을 설정하면 파드의 실행 시간에 제한을 두고 시간을 넘어서면 잡을 실패한것으로 처리할수도 있다.<li>backoffLimit 필드를 지정해 실패한것으로 표시되기 전에 잡을 재시도할수 있는 횟수도 설정할 수 있다.(기본값 6)</ul><h2 id="46-크론잡cronjon"><span class="mr-2">4.6 크론잡(CronJon)</span><a href="#46-크론잡cronjon" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>잡을 주기적으로 또는 한번만 실행되도록 스케줄링하기<li>많은 배치 잡이 미래의 특정 시간 또는 지정된 간격으로 반복 실행해야 한다. 쿠버네티스를 이를 지원하기 위한 크론잡 리소스 기능을 제공한다.</ul><h3 id="461-크론잡-정의"><span class="mr-2">4.6.1 크론잡 정의</span><a href="#461-크론잡-정의" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">batch/v1beta1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">CronJob</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">batch-job-every-fifteen-minutes</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">schedule</span><span class="pi">:</span> <span class="s2">"</span><span class="s">0,15,30,45</span><span class="nv"> </span><span class="s">*</span><span class="nv"> </span><span class="s">*</span><span class="nv"> </span><span class="s">*</span><span class="nv"> </span><span class="s">*"</span>     <span class="c1"># 매일 매시간 0,15,30,45분에 실행되는 cronJob</span>
  <span class="na">jobTemplate</span><span class="pi">:</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">template</span><span class="pi">:</span>
        <span class="na">metadata</span><span class="pi">:</span>
          <span class="na">labels</span><span class="pi">:</span>
            <span class="na">app</span><span class="pi">:</span> <span class="s">periodic-batch-job</span>
        <span class="na">spec</span><span class="pi">:</span>
          <span class="na">restartPolicy</span><span class="pi">:</span> <span class="s">OnFailure</span>
          <span class="na">containers</span><span class="pi">:</span>
          <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">main</span>
            <span class="na">image</span><span class="pi">:</span> <span class="s">luksa/batch-job</span>
</pre></table></code></div></div><h4 id="크론잡-생성-및-확인"><span class="mr-2">크론잡 생성 및 확인</span><a href="#크론잡-생성-및-확인" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="c"># 크론잡 생성</span>
kubectl create <span class="nt">-f</span> cronjob.yaml

<span class="c"># 크론잡 확인</span>
kubectl get cronjob

<span class="c"># 크론잡 삭제</span>
kubectl delete cronjob batch-job-every-fifteen-minutes
</pre></table></code></div></div><h3 id="462-스케줄된-잡의-실행-방법-이해"><span class="mr-2">4.6.2 스케줄된 잡의 실행 방법 이해</span><a href="#462-스케줄된-잡의-실행-방법-이해" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>예정된 시간을 너무 초과해서 시작되서는 안되는 엄격한 요구사항이 요구될떄도 있는데 이를 위한 옵션을 제공한다.<ul><li>startingDeadlineSeconds 필드를 지정( 초단위)</ul><li>일반적인 상황에서 크론잡은 스케줄에 설정한 각 실행에 항상 하나의 잡만 생성하지만, 2개의 잡이 동시에 생성되거나 전혀 생성되지 않을수도 있다.<ul><li>이런 문제를 해결하기 위해 멱등성(한번 실행이 아니라 여러번 실행해도 동일한 결과가 나타나야함)가지도록 개발해야 한다.<li>이전에 누락된 잡 실행이 있다면 다음번 작업에서 해당 작업을 같이 수행해주도록 개발하는것이 좋다.</ul></ul><h2 id="47-요약"><span class="mr-2">4.7 요약</span><a href="#47-요약" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>컨테이너가 더 이상 정상적이지 않으면 즉시 쿠버네티스가 컨테이너를 다시 시작하도록 라이브니스 프로브를 지정할 수 있다.<li>직접 생성한 파드는 실수로 삭제되거나 실행중인 노드에 장애가 발생하거나 노드에서 퇴출되면 다시 생성되지 않기 때문에 직접 생성해서 사용하면 안된다.<li>레플리케이션컨트롤러는 의도하는 수의 파드 복제본을 항상 실행 상태로 유지해준다.<li>파드를 수평으로 스케일링(확장)하려면 쉽게 레플리케이션컨트롤러에 의도하는 레플리카 수를 변경하는 것만으로도 가능하다.<li>파드는 레플리케이션컨트롤러가 소유하지 않으며, 필요한 경우 레플리케이션컨트롤러간에 이동할 수 있다.<li>템플릿을 변경해도 기존의 파드에는 영향을 미치지 않는다.<li>레플리카셋과 디폴로이먼트로 교체해야 하며, 레플리카셋과 디폴로이먼트는 동일한 기능을 제공하면서 추가적인 강력한 기능을 제공한다.<li>레플리카셋은 임의의 클러스턴 ㅗ드에 파드를 스케줄링하는 반면, 데몬셋은 모든 노드에 데몬셋이 정의한 파드의 인스턴스 하나만 실행되도록 한다.<li>배치 작업을 수행하는 파드는 쿠버네티스의 잡 리소스로 생성해야 한다.<li>특정 시점에 주기적으로 수행해야 하는 잡은 크론잡 리소스를 통해 생성할 수 있다.</ul><h2 id="reference"><span class="mr-2">Reference</span><a href="#reference" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><a href="https://www.manning.com/books/kubernetes-in-action">kubernetes-in-action</a><li><a href="https://kubernetes.io/ko/docs/home/">kubernetes.io</a></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/devlog/'>DevLog</a>, <a href='/categories/kubernetes/'>kubernetes</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/infra/" class="post-tag no-text-decoration" >Infra</a> <a href="/tags/kubernetes/" class="post-tag no-text-decoration" >kubernetes</a> <a href="/tags/kubernetes-in-action/" class="post-tag no-text-decoration" >kubernetes-in-action</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=[kubernetes-in-action]%204.%20%EB%A0%88%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EA%B3%BC%20%EA%B7%B8%20%EB%B0%96%EC%9D%98%20%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC%20:%20%EA%B4%80%EB%A6%AC%EB%90%98%EB%8A%94%20%ED%8C%8C%EB%93%9C%20%EB%B0%B0%ED%8F%AC%20-%20Sungsu's%20Tech%20Blog&url=https%3A%2F%2Fsungsu9022.github.io%2Fposts%2Fdevlog-platform-kubernetes-in-action4%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=[kubernetes-in-action]%204.%20%EB%A0%88%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EA%B3%BC%20%EA%B7%B8%20%EB%B0%96%EC%9D%98%20%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC%20:%20%EA%B4%80%EB%A6%AC%EB%90%98%EB%8A%94%20%ED%8C%8C%EB%93%9C%20%EB%B0%B0%ED%8F%AC%20-%20Sungsu's%20Tech%20Blog&u=https%3A%2F%2Fsungsu9022.github.io%2Fposts%2Fdevlog-platform-kubernetes-in-action4%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fsungsu9022.github.io%2Fposts%2Fdevlog-platform-kubernetes-in-action4%2F&text=[kubernetes-in-action]%204.%20%EB%A0%88%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EA%B3%BC%20%EA%B7%B8%20%EB%B0%96%EC%9D%98%20%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC%20:%20%EA%B4%80%EB%A6%AC%EB%90%98%EB%8A%94%20%ED%8C%8C%EB%93%9C%20%EB%B0%B0%ED%8F%AC%20-%20Sungsu's%20Tech%20Blog" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/es-bible-4-3/">[엘라스틱서치 바이블] 4. 데이터 다루기 -3(ES Client 라이브러리)</a><li><a href="/posts/es-bible-4-2/">[엘라스틱서치 바이블] 4. 데이터 다루기 -2(집계)</a><li><a href="/posts/es-bible-2/">[엘라스틱서치 바이블] 2. 엘라스틱 서치 기본 동작과 구조</a><li><a href="/posts/es-bible-3-1/">[엘라스틱서치 바이블] 3. 인덱스 설계 - 1</a><li><a href="/posts/spark-guide-6/">[스파크 완벽 가이드] 6. 다양한 데이터 타입 다루기</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/spark/">Spark</a> <a class="post-tag" href="/tags/infra/">Infra</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/kubernetes-in-action/">kubernetes-in-action</a> <a class="post-tag" href="/tags/kubernetes/">kubernetes</a> <a class="post-tag" href="/tags/elasticsearch/">Elasticsearch</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/effective-java/">Effective Java</a> <a class="post-tag" href="/tags/hands-on-reactive-programming-in-spring-5/">Hands-On Reactive Programming in Spring 5</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/devlog-platform-kubernetes-in-action1/"><div class="card-body"> <em class="small" data-ts="1596270840" data-df="ll" > Aug 1, 2020 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[kubernetes-in-action] 1. 쿠버네티스 소개</h3><div class="text-muted small"><p> 1. 쿠버네티스 소개 쿠버네티스 등장 배경 거대한 모놀리스 레거시 애플리케이션은 점차 마이크로 서비스라는 독립적으로 실행되는 더 작은 구성 요소로 세분화되고 있다. 마이크로 서비스는 서루 분리돼 있기 떄문에 개별적으로 개발, 배포, 업데이트, 확장할 수 있다. 이로써 오늘날 급변하는 비즈니스 요구사항을 충족시킬 만큼 신속하게 자주 구성 요소를 변...</p></div></div></a></div><div class="card"> <a href="/posts/devlog-platform-kubernetes-in-action2/"><div class="card-body"> <em class="small" data-ts="1596357240" data-df="ll" > Aug 2, 2020 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[kubernetes-in-action] 2. 도커와 쿠버네티스 첫걸음</h3><div class="text-muted small"><p> 2. 도커와 쿠버네티스 첫걸음 2.1 도커를 사용한 컨테이너 이미지 생성, 실행, 공유하기 2.1.1 Hello World 컨테이너 실행하기 docker run busybox echp &quot;Hello world&quot; 백그라운드에 일어난 동작 이해하기 docker run 명령을 수행했을 떄 일어나는 일들 2.1.2 간단한 node.js 애플리...</p></div></div></a></div><div class="card"> <a href="/posts/devlog-platform-kubernetes-in-action3/"><div class="card-body"> <em class="small" data-ts="1596443640" data-df="ll" > Aug 3, 2020 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[kubernetes-in-action] 3. 파드 : 쿠버네티스에서 컨테이너 실행</h3><div class="text-muted small"><p> 3. 파드 : 쿠버네티스에서 컨테이너 실행 3.1 파드 소개 파드는 함께 배치된 컨테이너 그룹이며, 쿠버네티스의 기본 빌딩 블록. 컨테이너를 개별적으로 배포하기보다는 컨테이너를 가진 파드를 배포하고, 운영한다. 무조건 2개 이상을 컨테이너를 포함시키라는 의미는 아니고 일반적으로는 하나의 컨테이너만 포함된다. 파드의 핵심은 파드가 여러 ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/devlog-platform-kubernetes-in-action3/" class="btn btn-outline-primary" prompt="Older"><p>[kubernetes-in-action] 3. 파드 : 쿠버네티스에서 컨테이너 실행</p></a> <a href="/posts/devlog-platform-kubernetes-in-action5/" class="btn btn-outline-primary" prompt="Newer"><p>[kubernetes-in-action] 5. 서비스 : 클라이언트가 파드를 검색하고 통신을 가능하게 함.</p></a></div><div id="disqus_thread" class="pt-2 pb-2"><p class="text-center text-muted small">Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script type="text/javascript"> var disqus_config = function () { this.page.url = 'https://sungsu9022.github.io/posts/devlog-platform-kubernetes-in-action4/'; this.page.identifier = '/posts/devlog-platform-kubernetes-in-action4/'; }; /* Lazy loading */ var disqus_observer = new IntersectionObserver( function (entries) { if (entries[0].isIntersecting) { (function () { var d = document, s = d.createElement('script'); s.src = 'https://sungsu-parks-tech-blog.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); disqus_observer.disconnect(); } }, { threshold: [0] } ); disqus_observer.observe(document.querySelector('#disqus_thread')); /* Auto switch theme */ function reloadDisqus() { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* Disqus hasn't been loaded */ if (typeof DISQUS === 'undefined') { return; } if (document.readyState == 'complete') { DISQUS.reset({ reload: true, config: disqus_config }); } } } if (document.querySelector('.mode-toggle')) { window.addEventListener('message', reloadDisqus); } </script></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/spark/">Spark</a> <a class="post-tag" href="/tags/infra/">Infra</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/kubernetes-in-action/">kubernetes-in-action</a> <a class="post-tag" href="/tags/kubernetes/">kubernetes</a> <a class="post-tag" href="/tags/elasticsearch/">Elasticsearch</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/effective-java/">Effective Java</a> <a class="post-tag" href="/tags/hands-on-reactive-programming-in-spring-5/">Hands-On Reactive Programming in Spring 5</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://twitter.com/sungsu9022dev">sungsu9022</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0">Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></div></footer><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-145894105-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-145894105-1'); }); </script>
