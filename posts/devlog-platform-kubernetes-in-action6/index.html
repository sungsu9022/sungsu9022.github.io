<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.3.3" /><meta property="og:title" content="[kubernetes-in-action] 6. 볼륨 : 컨테이너에 디스크 스토리지 연결" /><meta name="author" content="sungsu park" /><meta property="og:locale" content="en" /><meta name="description" content="6. 볼륨 : 컨테이너에 디스크 스토리지 연결 파드는 내부에 프로세스가 실행되고 CPU, RAM, 네트워크 인터페이스 등의 리소스를 공유한다. 하지만 디스크는 공유되지 않는다. 파드 내부의 각 컨테이너는 고유하게 분리된 파일 시스템을 가지기 때문이다.(컨테이너 이미지로부터 제공되는) 새로 시작한 컨테이너는 이전에 실행했던 컨테이너에 쓰여진 파일 시스템의 어떤 것도 볼수 없다. 전체 파일 시스템이 유지될 필요는 없지만 실제 데이터를 가진 디렉터리를 보존하고 싶을 수 있음. 이를 위해 쿠버네티스는 스토리지 볼륨으로 기능을 제공한다. 볼륨은 파드와 같은 최상위 리소스는 아니지만 파드의 일부분으로 정의되며 파드와 일반적으로는 동일한 라이프 사이클을 가진다." /><meta property="og:description" content="6. 볼륨 : 컨테이너에 디스크 스토리지 연결 파드는 내부에 프로세스가 실행되고 CPU, RAM, 네트워크 인터페이스 등의 리소스를 공유한다. 하지만 디스크는 공유되지 않는다. 파드 내부의 각 컨테이너는 고유하게 분리된 파일 시스템을 가지기 때문이다.(컨테이너 이미지로부터 제공되는) 새로 시작한 컨테이너는 이전에 실행했던 컨테이너에 쓰여진 파일 시스템의 어떤 것도 볼수 없다. 전체 파일 시스템이 유지될 필요는 없지만 실제 데이터를 가진 디렉터리를 보존하고 싶을 수 있음. 이를 위해 쿠버네티스는 스토리지 볼륨으로 기능을 제공한다. 볼륨은 파드와 같은 최상위 리소스는 아니지만 파드의 일부분으로 정의되며 파드와 일반적으로는 동일한 라이프 사이클을 가진다." /><link rel="canonical" href="https://sungsu9022.github.io/posts/devlog-platform-kubernetes-in-action6/" /><meta property="og:url" content="https://sungsu9022.github.io/posts/devlog-platform-kubernetes-in-action6/" /><meta property="og:site_name" content="Sungsu’s Tech Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-08-17T17:34:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[kubernetes-in-action] 6. 볼륨 : 컨테이너에 디스크 스토리지 연결" /><meta name="twitter:site" content="@sungsu9022dev" /><meta name="twitter:creator" content="@sungsu park" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"sungsu park"},"dateModified":"2020-08-17T17:34:00+09:00","datePublished":"2020-08-17T17:34:00+09:00","description":"6. 볼륨 : 컨테이너에 디스크 스토리지 연결 파드는 내부에 프로세스가 실행되고 CPU, RAM, 네트워크 인터페이스 등의 리소스를 공유한다. 하지만 디스크는 공유되지 않는다. 파드 내부의 각 컨테이너는 고유하게 분리된 파일 시스템을 가지기 때문이다.(컨테이너 이미지로부터 제공되는) 새로 시작한 컨테이너는 이전에 실행했던 컨테이너에 쓰여진 파일 시스템의 어떤 것도 볼수 없다. 전체 파일 시스템이 유지될 필요는 없지만 실제 데이터를 가진 디렉터리를 보존하고 싶을 수 있음. 이를 위해 쿠버네티스는 스토리지 볼륨으로 기능을 제공한다. 볼륨은 파드와 같은 최상위 리소스는 아니지만 파드의 일부분으로 정의되며 파드와 일반적으로는 동일한 라이프 사이클을 가진다.","headline":"[kubernetes-in-action] 6. 볼륨 : 컨테이너에 디스크 스토리지 연결","mainEntityOfPage":{"@type":"WebPage","@id":"https://sungsu9022.github.io/posts/devlog-platform-kubernetes-in-action6/"},"url":"https://sungsu9022.github.io/posts/devlog-platform-kubernetes-in-action6/"}</script><title>[kubernetes-in-action] 6. 볼륨 : 컨테이너에 디스크 스토리지 연결 | Sungsu's Tech Blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Sungsu's Tech Blog"><meta name="application-name" content="Sungsu's Tech Blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/personal/sunny.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">Sungsu's Tech Blog</a></div><div class="site-subtitle font-italic">Java/Kotlin Spring, Back-end</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/sungsu9022" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/sungsu9022dev" aria-label="twitter" target="_blank" rel="noopener noreferrer"> <i class="fab fa-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['sungsu9022','naver.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[kubernetes-in-action] 6. 볼륨 : 컨테이너에 디스크 스토리지 연결</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>[kubernetes-in-action] 6. 볼륨 : 컨테이너에 디스크 스토리지 연결</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1597653240" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Aug 17, 2020 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href=""></a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="5988 words"> <em>33 min</em> read</span></div></div></div><div class="post-content"><h1 id="6-볼륨--컨테이너에-디스크-스토리지-연결">6. 볼륨 : 컨테이너에 디스크 스토리지 연결</h1><ul><li>파드는 내부에 프로세스가 실행되고 CPU, RAM, 네트워크 인터페이스 등의 리소스를 공유한다. 하지만 디스크는 공유되지 않는다. 파드 내부의 각 컨테이너는 고유하게 분리된 파일 시스템을 가지기 때문이다.(컨테이너 이미지로부터 제공되는)<li>새로 시작한 컨테이너는 이전에 실행했던 컨테이너에 쓰여진 파일 시스템의 어떤 것도 볼수 없다.<li>전체 파일 시스템이 유지될 필요는 없지만 실제 데이터를 가진 디렉터리를 보존하고 싶을 수 있음.<li>이를 위해 쿠버네티스는 스토리지 볼륨으로 기능을 제공한다.<li>볼륨은 파드와 같은 최상위 리소스는 아니지만 파드의 일부분으로 정의되며 파드와 일반적으로는 동일한 라이프 사이클을 가진다.</ul><h2 id="61-볼륨-소개"><span class="mr-2">6.1 볼륨 소개</span><a href="#61-볼륨-소개" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>쿠버네티스 볼륨은 파드의 구성 요소로 컨테이너와 동일하게파드 스펙에서 정의된다.<li>볼륨은 독립적인 쿠버네티스 오브젝트가 아니므로 자체적으로 생성, 삭제될 수 없다.<li>접근하려는 컨테이너에서 각각 마운트 되어야 한다.</ul><h3 id="611-볼륨-예제"><span class="mr-2">6.1.1 볼륨 예제</span><a href="#611-볼륨-예제" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>볼륨 2개를 파드에 추가하고, 3개의 컨테이너 내부의 적절한 경로에 마운트<li>리눅스에서 파일시스템을 파일 트리의 임의 경로에 마운트할 수 있는 방식을 이용<li>같은 볼륨을 2개의 컨테이너에 마운트하면 컨테이너는 동일한 파일로 동작 가능하다.<li>마운트되지 않은 볼륨이 같은 파드안에 있더라도 접근할수 없고, 접근하려면 volumeMount를 컨테이너 스펙에 정의해야 한다.</ul><p><a href="https://user-images.githubusercontent.com/6982740/90376084-e2134100-e0b0-11ea-9e1f-4d2e231669ea.png" class="popup img-link "><img width="329" alt="스크린샷 2020-08-17 오후 5 41 21" data-src="https://user-images.githubusercontent.com/6982740/90376084-e2134100-e0b0-11ea-9e1f-4d2e231669ea.png" class="lazyload" data-proofer-ignore></a></p><h3 id="612-사용-가능한-볼륨-유형-소개"><span class="mr-2">6.1.2 사용 가능한 볼륨 유형 소개</span><a href="#612-사용-가능한-볼륨-유형-소개" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>emptyDir : 일시적인 데이터를 저장하는 데 사용되는 간단한 빈 디렉터리<li>hostPath : 워커 노드의 파일시스템을 파드의 디렉터리로 마운트<li>gitRepo : 깃 리포지터리의 콘텐츠를 체크아웃해 초기화한 볼륨<li>nft : NFS 공유를 파드에 마운트<li>gcePersistentDisk, awsElasticBlockStore, azureDisk 등 : 클라우드 제공자의 전용 스토리지 마운트<li>cinder, cephfs, iscsi, flocker, glusterfs, quobyte, rdb, flexVolume, vsphereVolume, photonPersistentDisk, scaleIO : 다른 유형의 네트워크 스토리지 마운트<li>configMap, secret, downwardAPI : 쿠버네티스 리소스나 클러스터 정보를 파드에 노출하는 데 사용되는 특별한 유형의 볼륨<li>persistentVolumeClaim : 사전 혹은 동적으로 프로비저닝된 퍼시스턴트 스토리지를 사용하는 방법</ul><h2 id="62-볼륨을-사용한-컨테이너간-데이터-공유"><span class="mr-2">6.2 볼륨을 사용한 컨테이너간 데이터 공유</span><a href="#62-볼륨을-사용한-컨테이너간-데이터-공유" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="621-emptydir-볼륨-사용"><span class="mr-2">6.2.1 emptyDir 볼륨 사용</span><a href="#621-emptydir-볼륨-사용" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>빈 디렉터리로 시작되며, 볼륨의 라이프사이클이 파드에 묶여 있으므로 파드가 삭제되면 볼륨의 콘텐츠도 같이 사라진다.<li>컨테이너에서 가용한 메모리에 넣기에 큰 데이터 세트의 정렬 작업을 수행하는 것과 같은 임시 데이터를 디스크에 쓰는 목적인 경우 사용할 수 있다.</ul><h4 id="파드에-emptydir-볼륨-사용동일한-볼륨을-공유하는-컨테이너-2개가-있는-파드"><span class="mr-2">파드에 emptyDir 볼륨 사용(동일한 볼륨을 공유하는 컨테이너 2개가 있는 파드)</span><a href="#파드에-emptydir-볼륨-사용동일한-볼륨을-공유하는-컨테이너-2개가-있는-파드" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">fortune</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">containers</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">image</span><span class="pi">:</span> <span class="s">luksa/fortune</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">html-generator</span>         <span class="c1"># 첫번째 컨테이너 html-generator</span>
    <span class="na">volumeMounts</span><span class="pi">:</span>                <span class="c1"># html이라는 이름의 볼륨을 컨테이너 /var/htdocs에 마운트</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">html</span>
      <span class="na">mountPath</span><span class="pi">:</span> <span class="s">/var/htdocs</span>
  <span class="pi">-</span> <span class="na">image</span><span class="pi">:</span> <span class="s">nginx:alpine</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">web-server</span>             <span class="c1"># 두번째 컨테이너 web-server</span>
    <span class="na">volumeMounts</span><span class="pi">:</span>                <span class="c1"># html이라는 이름의 볼륨을 컨테이너 /usr/share/nginx/html에 마운트</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">html</span>
      <span class="na">mountPath</span><span class="pi">:</span> <span class="s">/usr/share/nginx/html</span>
      <span class="na">readOnly</span><span class="pi">:</span> <span class="kc">true</span>
    <span class="na">ports</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">containerPort</span><span class="pi">:</span> <span class="m">80</span>
      <span class="na">protocol</span><span class="pi">:</span> <span class="s">TCP</span>
  <span class="na">volumes</span><span class="pi">:</span>                       <span class="c1"># html이라는 단일 emptyDir 볼륨을 위의 컨테이너 2개에 마운트하기 위한 정의</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">html</span>
    <span class="na">emptyDir</span><span class="pi">:</span> <span class="pi">{}</span>
</pre></table></code></div></div><h4 id="실행중인-파드-보기"><span class="mr-2">실행중인 파드 보기</span><a href="#실행중인-파드-보기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="c"># pod 조회</span>
kubectl get po

<span class="c"># fortune pod 포트 포워딩</span>
kubectl port-forward fortune 8080:80

<span class="c"># request</span>
curl http://localhost:8080

<span class="c"># html-generator 컨테이너 내부 확인</span>
kubectl <span class="nb">exec</span> <span class="nt">-i</span> <span class="nt">-t</span> fortune <span class="nt">-c</span> html-generator <span class="nt">--</span> /bin/bash

<span class="c"># web-server 컨테이너 index.html 파일 확인</span>
kubectl <span class="nb">exec</span> <span class="nt">-i</span> <span class="nt">-t</span> fortune <span class="nt">-c</span> web-server <span class="nt">--</span> <span class="nb">cat</span> /usr/share/nginx/html/index.html
</pre></table></code></div></div><h4 id="emptydir을-사용하기-위한-매체-지정하기"><span class="mr-2">emptyDir을 사용하기 위한 매체 지정하기</span><a href="#emptydir을-사용하기-위한-매체-지정하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>워커 노드의 실제 디스크에 생성하는 경우 노드 디스크가 어떤 유형인지에 따라 성능이 결정될수 있음.<li>쿠버네티스에 emptyDir을 디스크가 아닌 메모리를 사용하는 tmpfs 파일시스템으로 생성하도록 요청할수도 있음.</ul><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>  <span class="na">volumes</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">html</span>
    <span class="na">emptyDir</span><span class="pi">:</span>
        <span class="na">medium</span><span class="pi">:</span> <span class="s">Memory</span>   <span class="c1"># 이 emptyDir의 파일들은 메모리에 저장된다.</span>
</pre></table></code></div></div><h3 id="622-깃-리포지터리를-볼륨으로-사용하기"><span class="mr-2">6.2.2 깃 리포지터리를 볼륨으로 사용하기</span><a href="#622-깃-리포지터리를-볼륨으로-사용하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>gitRepo 볼륨은 emptyDir base이고, 파드가 시작되면 깃 리포를 복제하여 데이터를 채운다.<li>볼륨이 생성된 후에 참조하는 리포지터리와 동기화되지는 않는다. 파드가 삭제되고 새 파드가 생성되면 그 파드는 최신 커밋을 포함하게 된다.<li>최신 변경사항을 동기화하고 싶은 경우 github web hook 같은 것을 이용하면 될듯</ul><p><a href="https://user-images.githubusercontent.com/6982740/90379695-03c2f700-e0b6-11ea-9d25-44582f973fb1.png" class="popup img-link "><img width="603" alt="스크린샷 2020-08-17 오후 6 18 08" data-src="https://user-images.githubusercontent.com/6982740/90379695-03c2f700-e0b6-11ea-9d25-44582f973fb1.png" class="lazyload" data-proofer-ignore></a></p><h4 id="복제된-깃-리포지터리-파일을-서비스하는-웹-서버-실행하기"><span class="mr-2">복제된 깃 리포지터리 파일을 서비스하는 웹 서버 실행하기</span><a href="#복제된-깃-리포지터리-파일을-서비스하는-웹-서버-실행하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">gitrepo-volume-pod</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">containers</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">image</span><span class="pi">:</span> <span class="s">nginx:alpine</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">web-server</span>
    <span class="na">volumeMounts</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">html</span>
      <span class="na">mountPath</span><span class="pi">:</span> <span class="s">/usr/share/nginx/html</span>
      <span class="na">readOnly</span><span class="pi">:</span> <span class="kc">true</span>
    <span class="na">ports</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">containerPort</span><span class="pi">:</span> <span class="m">80</span>
      <span class="na">protocol</span><span class="pi">:</span> <span class="s">TCP</span>
  <span class="na">volumes</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">html</span>
    <span class="na">gitRepo</span><span class="pi">:</span>               <span class="c1"># gitRepo 정의하여 볼륨 정의 가능</span>
      <span class="na">repository</span><span class="pi">:</span> <span class="s">https://github.com/luksa/kubia-website-example.git</span>
      <span class="na">revision</span><span class="pi">:</span> <span class="s">master</span>
      <span class="na">directory</span><span class="pi">:</span> <span class="s">.</span>
</pre></table></code></div></div><h4 id="gitrepo-볼륨에-대한-정리"><span class="mr-2">gitRepo 볼륨에 대한 정리</span><a href="#gitrepo-볼륨에-대한-정리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>gitRepo 볼륨은 emptyDir 볼륨과 유사하게 기본적으로 볼륨을 포함하는 파드를 위해 특별히 생성되고 독점적으로 사용되는 전용 디렉터리이다.<li>파드가 삭제되면 볼륨과 콘텐츠는 모두 삭제된다.</ul><h2 id="63-워커-노드-파일시스템의-파일-접근"><span class="mr-2">6.3 워커 노드 파일시스템의 파일 접근</span><a href="#63-워커-노드-파일시스템의-파일-접근" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>대부분의 파드는 호스트 노드를 인식하지 못하므로 노드의 파일 시스템에 있는 어떤 파일에도 접근하면 안 된다.<li>하지만 특정 시스템 레벨의 파드(데몬셋과 같은)는 이런 파일 시스템 접근이 필요할 수 있다.<li>쿠버네티스는 hostPath 볼륨으로 이 기능을 지원한다.</ul><h3 id="631-hostpath-볼륨-소개"><span class="mr-2">6.3.1 hostPath 볼륨 소개</span><a href="#631-hostpath-볼륨-소개" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>hostPath 볼륨은 노드 파일 시스템의 특정 파일이나 디렉터리를 가리킨다.(퍼시스턴트 스토리지)<li>gitRepo나 emptyDir 볼륨의 콘텐츠는 파드가 종료되면 삭제되지만, hostPath 볼륨의 콘텐츠는 삭제되지 않는다.<li>이전 파드와 동일한 노드에서 새롭게 스케줄링 되는 새로운 파드는 이전 파드가 남긴 모든 항목을 볼 수 있다.<li>다만 데이터베이스의 데이터 디렉터리를 지정할 위치로 사용하기에는 적절하지 않다.(db pod은 다른 노드로 스케줄링 될 가능성이 있으므로)<li>hostPath 볼륨은 파드가 어떤 녿에 스케줄되느냐에 따라 민감하기 때문에 일반적인 파드에서는 사용하지 않는것이 좋다.</ul><p><a href="https://user-images.githubusercontent.com/6982740/90381984-20acf980-e0b9-11ea-8939-59fec001a61f.png" class="popup img-link "><img width="503" alt="스크린샷 2020-08-17 오후 6 40 24" data-src="https://user-images.githubusercontent.com/6982740/90381984-20acf980-e0b9-11ea-8939-59fec001a61f.png" class="lazyload" data-proofer-ignore></a></p><h3 id="632-hostpath-볼륨을-사용하는-시스템-파드-검사하기"><span class="mr-2">6.3.2 hostPath 볼륨을 사용하는 시스템 파드 검사하기</span><a href="#632-hostpath-볼륨을-사용하는-시스템-파드-검사하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>노드의 로그 파일이나 kubeconfig(쿠버네티스 구성 파일), CA 인증서를 접근하기 위한 데이터들을 hostPath로 구성되어있음<li>노드의 시스템 파일에 읽기/쓰기를 하는 경우에만 hostPath 볼륨을 사용해야 한다.(여러 파드에 걸쳐 데이터를 유지하기 위해서는 사용 금지)</ul><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="c"># kube-system 네임스페이스의 시스템 파드 조회</span>
kubectl get pods <span class="nt">--namespace</span> kube-system

<span class="c"># 시스템 파드 Path 확인</span>
kubectl describe po kube-controller-manager-minikube <span class="nt">--namespace</span> kube-system

<span class="c"># path 내용들</span>
ca-certs:
    Type:          HostPath <span class="o">(</span>bare host directory volume<span class="o">)</span>
    Path:          /etc/ssl/certs
    HostPathType:  DirectoryOrCreate
  flexvolume-dir:
    Type:          HostPath <span class="o">(</span>bare host directory volume<span class="o">)</span>
    Path:          /usr/libexec/kubernetes/kubelet-plugins/volume/exec
    HostPathType:  DirectoryOrCreate
  k8s-certs:
    Type:          HostPath <span class="o">(</span>bare host directory volume<span class="o">)</span>
    Path:          /var/lib/minikube/certs
    HostPathType:  DirectoryOrCreate
  kubeconfig:
    Type:          HostPath <span class="o">(</span>bare host directory volume<span class="o">)</span>
    Path:          /etc/kubernetes/controller-manager.conf
    HostPathType:  FileOrCreate
</pre></table></code></div></div><h2 id="64-퍼시스턴트-스토리지-사용"><span class="mr-2">6.4 퍼시스턴트 스토리지 사용</span><a href="#64-퍼시스턴트-스토리지-사용" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>파드에서 실행중인 애플리케이션이 디스크에 데이터를 유지해야 하고 파드가 다른 노드로 재스케줄링된 경우에도 동일한 데이터를 사용해야 하는 경우를 NAS 같은 유형에 데이터를 저장해야 한다.<li>이를 위한 방법을 쿠버네티스가 제공한다.<li>minikube로 연습하는 경우에는 hostPath 볼륨으로 사용하면 된다.</ul><h3 id="641-gce-퍼시스턴트-디스크를-파드-볼륨에-사용하기"><span class="mr-2">6.4.1 GCE 퍼시스턴트 디스크를 파드 볼륨에 사용하기</span><a href="#641-gce-퍼시스턴트-디스크를-파드-볼륨에-사용하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">mongodb</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">volumes</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">mongodb-data</span>
    <span class="na">gcePersistentDisk</span><span class="pi">:</span>                 <span class="c1"># 볼륨의 유형은 GCE 퍼시스턴트 디스크</span>
      <span class="na">pdName</span><span class="pi">:</span> <span class="s">mongodb</span>
      <span class="na">fsType</span><span class="pi">:</span> <span class="s">ext4</span>                         <span class="c1"># 리눅스 파일시스템 유형</span>
  <span class="na">containers</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">image</span><span class="pi">:</span> <span class="s">mongo</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">mongodb</span>
    <span class="na">volumeMounts</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">mongodb-data</span>
      <span class="na">mountPath</span><span class="pi">:</span> <span class="s">/data/db</span>           <span class="c1"># 컨테이너 내 마운트 되는 path</span>
    <span class="na">ports</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">containerPort</span><span class="pi">:</span> <span class="m">27017</span>
      <span class="na">protocol</span><span class="pi">:</span> <span class="s">TCP</span>
</pre></table></code></div></div><p><a href="https://user-images.githubusercontent.com/6982740/90383744-87cbad80-e0bb-11ea-95b7-f3534c77f9b0.png" class="popup img-link "><img width="593" alt="스크린샷 2020-08-17 오후 6 57 35" data-src="https://user-images.githubusercontent.com/6982740/90383744-87cbad80-e0bb-11ea-95b7-f3534c77f9b0.png" class="lazyload" data-proofer-ignore></a></p><h3 id="642-기반-퍼시스턴트-스토리지로-다른-유형의-볼륨-사용하기"><span class="mr-2">6.4.2 기반 퍼시스턴트 스토리지로 다른 유형의 볼륨 사용하기</span><a href="#642-기반-퍼시스턴트-스토리지로-다른-유형의-볼륨-사용하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>awsElasticBlockStore, azureFile이나 azureDisk 볼륨을 사용할 수 있음.</ul><h4 id="aws-elastic-block-store-볼륨-사용"><span class="mr-2">AWS Elastic Block Store 볼륨 사용</span><a href="#aws-elastic-block-store-볼륨-사용" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">mongodb-aws</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">volumes</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">mongodb-data</span>
    <span class="na">awsElasticBlockStore</span><span class="pi">:</span>                 <span class="c1"># awsElasticBlockStore</span>
      <span class="na">volumeID</span><span class="pi">:</span> <span class="s">my-volume</span>
      <span class="na">fsType</span><span class="pi">:</span> <span class="s">ext4</span>
<span class="nn">...</span>
</pre></table></code></div></div><h4 id="nfs-볼륨-사용"><span class="mr-2">NFS 볼륨 사용</span><a href="#nfs-볼륨-사용" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">mongodb-nfs</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">volumes</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">mongodb-data</span>
    <span class="na">nfs</span><span class="pi">:</span>
      <span class="na">server</span><span class="pi">:</span> <span class="s">1.2.3.4</span>
      <span class="na">path</span><span class="pi">:</span> <span class="s">/some/path</span>
<span class="nn">...</span>
</pre></table></code></div></div><h4 id="다른-스토리지-기술-사용"><span class="mr-2">다른 스토리지 기술 사용</span><a href="#다른-스토리지-기술-사용" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>쿠버네티스는 왠만한 모든 기술의 다양한 스토리지를 지원한다.</ul><h2 id="65-기반-스토리지-기술과-파드-분리"><span class="mr-2">6.5 기반 스토리지 기술과 파드 분리</span><a href="#65-기반-스토리지-기술과-파드-분리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>쿠버네티스에 앱을 배포하는 개발자는 기저에 어떤 종류의 스토리지 기술이 사용되는 알 필요 없어야 하고, 동일한 방식으로 파드를 실행하기 위해 어떤 유형의 물리 서버가 사용되는지 알 필요 없어야 한다.(이상적)<li>파드의 볼륨이 실제 기반 인프라스르럭처를 참조한다는 것은 쿠버네티스가 추구하는 바가 아님<li>인프라 스트럭처 관련 정보를 파드 정의에 포함한다는 것은 파드 정의가 특정 쿠버네티스 클러슽에 밀접하게 연결됨을 의미한다. 동일한 파드 정의를 다른 클러스터에서는 사용할 수 없다.</ul><h3 id="651-퍼시스턴트볼륨pv-persistentvolume과-퍼시스턴트볼륨클레임pvc-persistentvolumeclaim"><span class="mr-2">6.5.1 퍼시스턴트볼륨(PV, PersistentVolume)과 퍼시스턴트볼륨클레임(PVC, PersistentVolumeClaim)</span><a href="#651-퍼시스턴트볼륨pv-persistentvolume과-퍼시스턴트볼륨클레임pvc-persistentvolumeclaim" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>인프라스트럭처의 세부 사항을 처리하지 않고 앱이 스토리지를 요청할 수 있도록 하기 위한 리소스 유형<li>관리자는 네트워크 스토리지 유형을 서정하고, PV 디스크립터를 게시하여 퍼시스턴트볼륨을 생성한다.<li>사용자는 퍼시스턴트볼륨클레임(PVC)을 생성하면, 쿠버네티스가 적당한 크기와 접근모드의 PV를 찾아서 PVC를 PV에 바인딩시킨다.<li>사용자는 이제 PVC를 참조하는 볼륨을 가진 파드를 생성한다.</ul><p><a href="https://user-images.githubusercontent.com/6982740/90384690-ee050000-e0bc-11ea-8704-dc68264d66e7.png" class="popup img-link "><img width="574" alt="스크린샷 2020-08-17 오후 7 07 36" data-src="https://user-images.githubusercontent.com/6982740/90384690-ee050000-e0bc-11ea-8704-dc68264d66e7.png" class="lazyload" data-proofer-ignore></a></p><h3 id="652-퍼시스턴트볼륨-생성"><span class="mr-2">6.5.2 퍼시스턴트볼륨 생성</span><a href="#652-퍼시스턴트볼륨-생성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>퍼시스턴트볼륨을 생성할 때 동시에 단일 또는 다수 노드에 읽기나 쓰기가 가능한지 여부 등을 지정해야 하고, 퍼시스턴트볼륨 해제시 어떤 동작을 해야 할지 정의해야 한다.<li>퍼시스턴트 볼륨을 지원하는 실제 스토리지의 유형, 위치, 그 밖의 속성 정보를 지정<li>퍼시스턴트 볼륨은 특정 네임스페이스에 속하지 않고, 노드와 같은 수준의 클러스터 리소스이다.</ul><h4 id="정의"><span class="mr-2">정의</span><a href="#정의" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">PersistentVolume</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">mongodb-pv</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">capacity</span><span class="pi">:</span>
    <span class="na">storage</span><span class="pi">:</span> <span class="s">1Gi</span>
  <span class="na">accessModes</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">ReadWriteOnce</span>                        <span class="c1"># 단일 클라이언트의 읽기/쓰기용으로 마운트</span>
    <span class="pi">-</span> <span class="s">ReadOnlyMany</span>                         <span class="c1"># 여러 클라이언트의 읽기 전용으로 마운트</span>
  <span class="na">persistentVolumeReclaimPolicy</span><span class="pi">:</span> <span class="s">Retain</span>    <span class="c1"># 클레임이 해제된 후 퍼시스턴트볼륨을 유지한다.</span>
  <span class="na">hostPath</span><span class="pi">:</span>                                <span class="c1"># ohstPath 볼륨 (minikube)</span>
    <span class="na">path</span><span class="pi">:</span> <span class="s">/tmp/mongodb</span>
</pre></table></code></div></div><h4 id="persistentvolumereclaimpolicy"><span class="mr-2">persistentVolumeReclaimPolicy</span><a href="#persistentvolumereclaimpolicy" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><blockquote><p>현재 NFS 및 HostPath만 재활용을 지원한다. AWS EBS, GCE PD, Azure Disk 및 Cinder 볼륨은 삭제를 지원한다.</p></blockquote><ul><li>Retain(보존) – 수동 반환<li>Recycle(재활용) – 기본 스크럽 (rm -rf /thevolume/*)<li>Delete(삭제) – AWS EBS, GCE PD, Azure Disk 또는 OpenStack Cinder 볼륨과 같은 관련 스토리지 자산이 삭제됨</ul><h4 id="생성-및-조회"><span class="mr-2">생성 및 조회</span><a href="#생성-및-조회" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c"># hostPath PV 생성</span>
kubectl create <span class="nt">-f</span> mongodb-pv-hostpath.yaml

<span class="c"># pv 조회</span>
kubectl get pv
</pre></table></code></div></div><p><a href="https://user-images.githubusercontent.com/6982740/90386041-f0685980-e0be-11ea-8ce2-33cdac104986.png" class="popup img-link "><img width="612" alt="스크린샷 2020-08-17 오후 7 22 00" data-src="https://user-images.githubusercontent.com/6982740/90386041-f0685980-e0be-11ea-8ce2-33cdac104986.png" class="lazyload" data-proofer-ignore></a></p><h3 id="653-퍼시스턴트볼륨클레임-생성을-통한-퍼시스턴트볼륨-요청"><span class="mr-2">6.5.3 퍼시스턴트볼륨클레임 생성을 통한 퍼시스턴트볼륨 요청</span><a href="#653-퍼시스턴트볼륨클레임-생성을-통한-퍼시스턴트볼륨-요청" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>파드가 재스케줄링되더라도 동일한 퍼시스턴트볼륨클레임이 사용 가능한 상태로 유지되기를 원하므로 퍼시스턴트 볼륨에 대한 클레임은 파드를 생성하는 것과 별개의 프로세스이다.</ul><h4 id="퍼시스턴트볼륨클레임-생성하기"><span class="mr-2">퍼시스턴트볼륨클레임 생성하기</span><a href="#퍼시스턴트볼륨클레임-생성하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>퍼시스턴트볼륨클레임이 생성되자마자 쿠버네티스는 적절한 퍼시스턴트볼륨을 찾고 클레임에 바인딩한다.<li>용량은 퍼시스턴트볼륨클레임의 요청을 수용할만큼 충분히 커야하고, 볼륨 접근 모드는 클레임에서 요청한 접근모드를 포함하는 상태여야 바인딩이 이루어진다.</ul><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">PersistentVolumeClaim</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">mongodb-pvc</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">resources</span><span class="pi">:</span>
    <span class="na">requests</span><span class="pi">:</span>                         <span class="c1"># 1GiB의 스토리지를 요청</span>
      <span class="na">storage</span><span class="pi">:</span> <span class="s">1Gi</span>
  <span class="na">accessModes</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">ReadWriteOnce</span>               <span class="c1"># 단일 클라이언트를 지원하는 읽기/쓰기 스토리지</span>
  <span class="na">storageClassName</span><span class="pi">:</span> <span class="s2">"</span><span class="s">"</span>
</pre></table></code></div></div><h4 id="퍼시스턴트볼륨클레임-조회하기"><span class="mr-2">퍼시스턴트볼륨클레임 조회하기</span><a href="#퍼시스턴트볼륨클레임-조회하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c"># 퍼시스턴트볼륨클레임 생성</span>
kubectl create <span class="nt">-f</span> mongodb-pvc.yaml

<span class="c"># 퍼시스턴트볼륨클레임 조회</span>
kubectl get pvc
</pre></table></code></div></div><h4 id="퍼시스턴트볼륨-접근모드"><span class="mr-2">퍼시스턴트볼륨 접근모드</span><a href="#퍼시스턴트볼륨-접근모드" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>RWO(ReadWriteOnce) : 단일 노드만이 읽기/쓰기용으로 볼륨을 마운트<li>ROX(ReadOnlyMany) : 다수 노드가 읽읽기용으로 볼륨을 마운트<li>RWX(ReadWriteMany) : 다수 노드가 읽기/쓰기용으로 볼륨을 마운트</ul><h3 id="654-파드에서-퍼시스턴트볼륨클레임-사용하기"><span class="mr-2">6.5.4 파드에서 퍼시스턴트볼륨클레임 사용하기</span><a href="#654-파드에서-퍼시스턴트볼륨클레임-사용하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">mongodb</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">containers</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">image</span><span class="pi">:</span> <span class="s">mongo</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">mongodb</span>
    <span class="na">volumeMounts</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">mongodb-data</span>
      <span class="na">mountPath</span><span class="pi">:</span> <span class="s">/data/db</span>
    <span class="na">ports</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">containerPort</span><span class="pi">:</span> <span class="m">27017</span>
      <span class="na">protocol</span><span class="pi">:</span> <span class="s">TCP</span>
  <span class="na">volumes</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">mongodb-data</span>                <span class="c1"># 파드 볼륨에서 이름으로 퍼시스턴트볼륨클레임을 참조</span>
    <span class="na">persistentVolumeClaim</span><span class="pi">:</span>
      <span class="na">claimName</span><span class="pi">:</span> <span class="s">mongodb-pvc</span>
</pre></table></code></div></div><h4 id="mongodb-test"><span class="mr-2">mongodb test</span><a href="#mongodb-test" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="c"># 퍼시스턴트클레임을 이용하는 mongodb pod 생성</span>
kubectl create <span class="nt">-f</span> mongodb-pod-pvc.yaml

<span class="c"># mongodb 셸 접속</span>
kubectl <span class="nb">exec</span> <span class="nt">-it</span> mongodb mongo

<span class="c"># mongodb db 변경</span>
use mystore

<span class="c"># 데이터 insert</span>
db.foo.insert<span class="o">({</span>name:<span class="s1">'foo'</span><span class="o">})</span>

<span class="c"># 데이터 조회</span>
db.foo.find<span class="o">()</span>
</pre></table></code></div></div><h3 id="655-퍼시스턴트볼륨과-퍼시스턴트볼륨클레임-사용의-장점-이해하기"><span class="mr-2">6.5.5 퍼시스턴트볼륨과 퍼시스턴트볼륨클레임 사용의 장점 이해하기</span><a href="#655-퍼시스턴트볼륨과-퍼시스턴트볼륨클레임-사용의-장점-이해하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>GCE 퍼시스터턴트 디스크를 직접 사용하는 경우와 PVC + PV를 사용하는 경우 비교<li>개발자가 직접 인프라스트럭처에서 스토리지를 가져오는 방식보다는 PV + PVC을 통해간접적으로 가져오는 방식이 더 간단하다(인프라스트럭처를 몰라도됨)<li>또한 동일한 파드와 클레임 매니페스트는 인프라스트럭처와는 관련된 어떤것도 참조하지 않으므로 다른 쿠버네티스 클러스터에서도 그대로 사용할 수 있다.<li>“클레임은 x만큼의 스토리지가 필요하고 한 번에 하나의 클라이언트에서 읽기와 쓰기를 할 수 있어야 한다”만 명시한다.</ul><p><a href="https://user-images.githubusercontent.com/6982740/90408022-371b7b00-e0e2-11ea-9d36-ba056fbc2b43.png" class="popup img-link "><img width="595" alt="스크린샷 2020-08-17 오후 11 34 27" data-src="https://user-images.githubusercontent.com/6982740/90408022-371b7b00-e0e2-11ea-9d36-ba056fbc2b43.png" class="lazyload" data-proofer-ignore></a></p><h3 id="656-퍼시스턴트볼륨-재사용"><span class="mr-2">6.5.6 퍼시스턴트볼륨 재사용</span><a href="#656-퍼시스턴트볼륨-재사용" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="c"># mongodb pod 삭제</span>
kubectl delete pod mongodb

<span class="c"># pvc 삭제</span>
kubectl delete pvc mongodb-pvc

<span class="c">#pvc, pod 재생성 ( 이 경우 pvc는 바로 volume을 할당받지 못하고 Pending 상태가 된다.)</span>
kubectl create <span class="nt">-f</span> mongodb-pvc.yaml
kubectl create <span class="nt">-f</span> mongodb-pod-pvc.yaml

<span class="c"># pvc 조회</span>
kubectl get pvc

<span class="c"># pv 조회 ( 퍼시스턴트볼륨의 상태가 Released로 표시되고 Available이 아니다. 그 이유는 이미 볼륨을 사용했기 떄문에 데이터를 가지고 있어서 새로운 클레임을 바인딩할 수 없는 상태)</span>
kubectl get pv
</pre></table></code></div></div><h4 id="퍼시스턴트볼륨을-수동으로-다시-클레임하기"><span class="mr-2">퍼시스턴트볼륨을 수동으로 다시 클레임하기</span><a href="#퍼시스턴트볼륨을-수동으로-다시-클레임하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>persistentVolumeClaimPolicy를 Retain으로 설정하면 퍼시스턴트볼륨클레임이 해제되더라도 데이터가 남아있으면 상태가 Available로 풀리지 않는다.</ul><h4 id="퍼시스턴트볼륨을-자동으로-다시-클레임하기"><span class="mr-2">퍼시스턴트볼륨을 자동으로 다시 클레임하기</span><a href="#퍼시스턴트볼륨을-자동으로-다시-클레임하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>다른 리클레임 정책인 Recycle과 Delete가 있는데 Recycle은 볼륨의 콘텐츠를 삭제하고 다시 클레임될수 있도록 만드는 옵션이다.<li>Delete 정책은 쿠버네티스에서 퍼시스턴트볼륨 오브젝트와 외부 인프라(예: AWS EBS, GCE PD, Azure Disk 또는 Cinder 볼륨)의 관련 스토리지 자산을 모두 삭제한다.<li>Recycle과 Delete의 차이는 pvc가 삭제될때 pv까지 삭제하느냐 안하느냐에 대한 차이가 있음(Delete는 pvc를 삭제하면 pv까지 삭제함)</ul><p><a href="https://user-images.githubusercontent.com/6982740/90413802-ed369300-e0e9-11ea-9768-cbf5f29b2f5b.png" class="popup img-link "><img width="684" alt="스크린샷 2020-08-18 오전 12 29 06" data-src="https://user-images.githubusercontent.com/6982740/90413802-ed369300-e0e9-11ea-9768-cbf5f29b2f5b.png" class="lazyload" data-proofer-ignore></a></p><h2 id="66-퍼시스턴트볼륨의-동적-프로비저닝"><span class="mr-2">6.6 퍼시스턴트볼륨의 동적 프로비저닝</span><a href="#66-퍼시스턴트볼륨의-동적-프로비저닝" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="662-퍼시스턴트볼륨클레임에서-스토리지-클래스-요청하기"><span class="mr-2">6.6.2 퍼시스턴트볼륨클레임에서 스토리지 클래스 요청하기</span><a href="#662-퍼시스턴트볼륨클레임에서-스토리지-클래스-요청하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="특정-스토리지클래스를-요청하는-pvc-정의"><span class="mr-2">특정 스토리지클래스를 요청하는 pvc 정의</span><a href="#특정-스토리지클래스를-요청하는-pvc-정의" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>클레임을 생성하면 fast 스토리지클래스 리소스에 참조된 프로비저너가 퍼시스턴트볼륨을 생성한다.<li>PVC에서 존재하지 않는 스토리지클래스를 참조하면 PV 프로비저닝은 실패한다.<li>kubectl describe 로 확인해보면 ProvisioningFailed 이벤트 표시됨.</ul><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">PersistentVolumeClaim</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">mongodb-pvc</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">storageClassName</span><span class="pi">:</span> <span class="s">fast</span>           <span class="c1"># PVC는 사용자 정의 스토리지 클래스를 요청</span>
  <span class="na">resources</span><span class="pi">:</span>
    <span class="na">requests</span><span class="pi">:</span>
      <span class="na">storage</span><span class="pi">:</span> <span class="s">100Mi</span>
  <span class="na">accessModes</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">ReadWriteOnce</span>
</pre></table></code></div></div><h4 id="스토리지클래스-정의"><span class="mr-2">스토리지클래스 정의</span><a href="#스토리지클래스-정의" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">storage.k8s.io/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">StorageClass</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">fast</span>
<span class="na">provisioner</span><span class="pi">:</span> <span class="s">k8s.io/minikube-hostpath</span>
<span class="na">parameters</span><span class="pi">:</span>
  <span class="na">type</span><span class="pi">:</span> <span class="s">pd-ssd</span>

</pre></table></code></div></div><h4 id="동적-프로비저닝된-pv와-생성된-pvc-조회"><span class="mr-2">동적 프로비저닝된 PV와 생성된 PVC 조회</span><a href="#동적-프로비저닝된-pv와-생성된-pvc-조회" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>이렇게 생성된 PV는 리클레임 정책 Delete을 가지며, PVC가 삭제되면 PV도 삭제된다.</ul><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="c"># 스토리지클래스 생성</span>
kubectl create <span class="nt">-f</span> storageclass-fast-hostpath.yaml

<span class="c"># PVC 생성</span>
kubectl create <span class="nt">-f</span> mongodb-pvc-dp.yaml

<span class="c"># pvc 조회</span>
kubectl get pvc

NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                 STORAGECLASS   REASON   AGE
mongodb-pvc   Bound    pvc-b767134f-218a-48cc-b1a4-4787a661fd09   100Mi      RWO            fast           16m

<span class="c"># pv 조회</span>
kubectl get pv
NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                 STORAGECLASS   REASON   AGE
pvc-b767134f-218a-48cc-b1a4-4787a661fd09   100Mi      RWO            Delete           Bound    default/mongodb-pvc   fast                    16m
</pre></table></code></div></div><h4 id="스토리지-클래스-사용하는-법-이해하기"><span class="mr-2">스토리지 클래스 사용하는 법 이해하기</span><a href="#스토리지-클래스-사용하는-법-이해하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>스토리지클래스의 좋은 점은 클레임 이름으로 이를 참조한다는 사실. 그래서 다른 클러스터간 스토리지클래스 이름을 동일하게 사용한다면 PVC 정의를 다른 클러스터로 이식도 가능하다.</ul><h3 id="663-스토리지-클래스를-지정하지-않는-동적-프로비저닝"><span class="mr-2">6.6.3 스토리지 클래스를 지정하지 않는 동적 프로비저닝</span><a href="#663-스토리지-클래스를-지정하지-않는-동적-프로비저닝" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="c"># 스토리지 클래스 조회</span>
kubectl get sc

NAME                 PROVISIONER                RECLAIMPOLICY   VOLUMEBINDINGMODE   ALLOWVOLUMEEXPANSION   AGE
fast                 k8s.io/minikube-hostpath   Delete          Immediate           <span class="nb">false                  </span>18m
standard <span class="o">(</span>default<span class="o">)</span>   k8s.io/minikube-hostpath   Delete          Immediate           <span class="nb">false                  </span>26h

<span class="c"># 기본 스토리지 클래스 확인</span>
kubectl get sc standard <span class="nt">-o</span> yaml
</pre></table></code></div></div><h4 id="스토리지-클래스를-지정하지-않고-퍼시스턴트볼륨클레임-생성하기"><span class="mr-2">스토리지 클래스를 지정하지 않고 퍼시스턴트볼륨클레임 생성하기</span><a href="#스토리지-클래스를-지정하지-않고-퍼시스턴트볼륨클레임-생성하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">PersistentVolumeClaim</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">mongodb-pvc2</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">resources</span><span class="pi">:</span>
    <span class="na">requests</span><span class="pi">:</span>
      <span class="na">storage</span><span class="pi">:</span> <span class="s">100Mi</span>
  <span class="na">accessModes</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">ReadWriteOnce</span>
</pre></table></code></div></div><ul><li>storageClassName 속성을 지정하지 않고 PVC를 생성하면 구글 쿠버네티스 엔진에서는 pd-standard 유형의 퍼시스턴트 디스크가 프로비저닝된다.</ul><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="c"># 스토리지 클래스를 지정하지 않고 pvc 생성</span>
kubectl create <span class="nt">-f</span> mongodb-pvc-dp-nostorageclass.yaml

<span class="c"># pvc 확인</span>
kubectl get pvc

<span class="c"># pv 확인</span>
kubectl get pv
</pre></table></code></div></div><h4 id="퍼시스턴트볼륨클레임을-미리-프로비저닝된-퍼시스턴트볼륨으로-바인딩-강제화하기"><span class="mr-2">퍼시스턴트볼륨클레임을 미리 프로비저닝된 퍼시스턴트볼륨으로 바인딩 강제화하기</span><a href="#퍼시스턴트볼륨클레임을-미리-프로비저닝된-퍼시스턴트볼륨으로-바인딩-강제화하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>storageClassName 속성을 빈 문자열로 지정하지 않으면 미리 프로비저닝된 퍼시스턴트볼륨이 있다고 할지라도 동적 볼륨 프로비저너는 새로운 퍼시스턴트볼륨을 프로비저닝한다.<li>미리 프로비저닝된 PV에 바인딩하기 위해서는(미리 만들어둔 PV에 바인딩하려면) 명시적으로 storageClassName을 ““로 지정해야 한다.</ul><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">PersistentVolumeClaim</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">mongodb-pvc</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">resources</span><span class="pi">:</span>
    <span class="na">requests</span><span class="pi">:</span>
      <span class="na">storage</span><span class="pi">:</span> <span class="s">1Gi</span>
  <span class="na">accessModes</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">ReadWriteOnce</span>
  <span class="na">storageClassName</span><span class="pi">:</span> <span class="s2">"</span><span class="s">"</span>      <span class="c1"># 빈 문자열을 스토리지클래스 이름으로 지정하면 PVC가 새로운 PV를 동적 프로비저닝하지 않고 미리 프로비저닝된 PV에 바인딩된다.</span>
</pre></table></code></div></div><h4 id="퍼시스턴트볼륨-동적-프로비저닝의-플로우"><span class="mr-2">퍼시스턴트볼륨 동적 프로비저닝의 플로우</span><a href="#퍼시스턴트볼륨-동적-프로비저닝의-플로우" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>클러스터 관리자는 퍼시스턴트볼륨 프로비저너를 설정하고, 하나 이상의 스토리지 클래스를 생성하고 기본값 정의<li>사용자는 스토리지클래스 중 하나를 참조해 PVC를 생성<li>PVC는 스토리지클래스와 거기서 참조된 프로비저너를 보고 PVC로 요청된 접근모드, 스토리지 크기, 파라미터를 기반으로 새 PV를 프로비저닝하도록 요청<li>프로비저너는 스토리지를 프로비저닝하고 PV를 생성한 후 PVC에 바인딩한다.<li>사용자는 PVC를 이름으로 참조하는 볼륨과 파드를 생성</ul><p><a href="https://user-images.githubusercontent.com/6982740/90413845-fe7f9f80-e0e9-11ea-8bf2-7be6c28b94dc.png" class="popup img-link "><img width="682" alt="스크린샷 2020-08-18 오전 12 30 12" data-src="https://user-images.githubusercontent.com/6982740/90413845-fe7f9f80-e0e9-11ea-8bf2-7be6c28b94dc.png" class="lazyload" data-proofer-ignore></a></p><h2 id="67-요약"><span class="mr-2">6.7 요약</span><a href="#67-요약" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>다중 컨테이너 파드 생성과 파드의 컨테이너들이 볼륨을 파드에 추가하고 각 컨테이너에 마운트해 동일한 파일로 동작하게 할 수 있다.<li>emptyDir 볼륨을 사용해 임시, 비영구 데이터를 저장할 수 있다.<li>gitRepo 볼륨을 사용해 파드의 시작 시점에 깃 리포지터리의 콘텐츠로 디렉터리를 쉽게 채울수 있다.<li>hostpath 볼륨을 사용해 호스트 노드의 파일에 접근한다.<li>외부 스토리지를 볼륨에 마운트해 파드가 재시작돼도 파드의 데이터를 유지한다.<li>퍼시스턴트볼륨과 퍼시스턴트볼륨클레임을 사용해 파드와 스토리지 인프라스트럭처를 분리할수 있다.<li>스토리지클래스를 이용하면 PVC가 원하는 만큼의 PV를 프로비저닝할 수 있다.<li>PVC을 미리 프로비저닝된 PV에 바인딩하고자 할 때 동적 프로비저너가 간섭하는 것을 막을 수도 있다.</ul><h2 id="reference"><span class="mr-2">Reference</span><a href="#reference" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><a href="https://www.manning.com/books/kubernetes-in-action">kubernetes-in-action</a><li><a href="https://kubernetes.io/ko/docs/home/">kubernetes.io</a></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/devlog/'>DevLog</a>, <a href='/categories/kubernetes/'>kubernetes</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/infra/" class="post-tag no-text-decoration" >Infra</a> <a href="/tags/kubernetes/" class="post-tag no-text-decoration" >kubernetes</a> <a href="/tags/kubernetes-in-action/" class="post-tag no-text-decoration" >kubernetes-in-action</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=[kubernetes-in-action]%206.%20%EB%B3%BC%EB%A5%A8%20:%20%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EC%97%90%20%EB%94%94%EC%8A%A4%ED%81%AC%20%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80%20%EC%97%B0%EA%B2%B0%20-%20Sungsu's%20Tech%20Blog&url=https%3A%2F%2Fsungsu9022.github.io%2Fposts%2Fdevlog-platform-kubernetes-in-action6%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=[kubernetes-in-action]%206.%20%EB%B3%BC%EB%A5%A8%20:%20%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EC%97%90%20%EB%94%94%EC%8A%A4%ED%81%AC%20%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80%20%EC%97%B0%EA%B2%B0%20-%20Sungsu's%20Tech%20Blog&u=https%3A%2F%2Fsungsu9022.github.io%2Fposts%2Fdevlog-platform-kubernetes-in-action6%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fsungsu9022.github.io%2Fposts%2Fdevlog-platform-kubernetes-in-action6%2F&text=[kubernetes-in-action]%206.%20%EB%B3%BC%EB%A5%A8%20:%20%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EC%97%90%20%EB%94%94%EC%8A%A4%ED%81%AC%20%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80%20%EC%97%B0%EA%B2%B0%20-%20Sungsu's%20Tech%20Blog" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/es-bible-4-3/">[엘라스틱서치 바이블] 4. 데이터 다루기 -3(ES Client 라이브러리)</a><li><a href="/posts/es-bible-4-2/">[엘라스틱서치 바이블] 4. 데이터 다루기 -2(집계)</a><li><a href="/posts/es-bible-2/">[엘라스틱서치 바이블] 2. 엘라스틱 서치 기본 동작과 구조</a><li><a href="/posts/es-bible-3-1/">[엘라스틱서치 바이블] 3. 인덱스 설계 - 1</a><li><a href="/posts/spark-guide-6/">[스파크 완벽 가이드] 6. 다양한 데이터 타입 다루기</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/spark/">Spark</a> <a class="post-tag" href="/tags/infra/">Infra</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/kubernetes-in-action/">kubernetes-in-action</a> <a class="post-tag" href="/tags/kubernetes/">kubernetes</a> <a class="post-tag" href="/tags/elasticsearch/">Elasticsearch</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/effective-java/">Effective Java</a> <a class="post-tag" href="/tags/hands-on-reactive-programming-in-spring-5/">Hands-On Reactive Programming in Spring 5</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/devlog-platform-kubernetes-in-action1/"><div class="card-body"> <em class="small" data-ts="1596270840" data-df="ll" > Aug 1, 2020 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[kubernetes-in-action] 1. 쿠버네티스 소개</h3><div class="text-muted small"><p> 1. 쿠버네티스 소개 쿠버네티스 등장 배경 거대한 모놀리스 레거시 애플리케이션은 점차 마이크로 서비스라는 독립적으로 실행되는 더 작은 구성 요소로 세분화되고 있다. 마이크로 서비스는 서루 분리돼 있기 떄문에 개별적으로 개발, 배포, 업데이트, 확장할 수 있다. 이로써 오늘날 급변하는 비즈니스 요구사항을 충족시킬 만큼 신속하게 자주 구성 요소를 변...</p></div></div></a></div><div class="card"> <a href="/posts/devlog-platform-kubernetes-in-action2/"><div class="card-body"> <em class="small" data-ts="1596357240" data-df="ll" > Aug 2, 2020 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[kubernetes-in-action] 2. 도커와 쿠버네티스 첫걸음</h3><div class="text-muted small"><p> 2. 도커와 쿠버네티스 첫걸음 2.1 도커를 사용한 컨테이너 이미지 생성, 실행, 공유하기 2.1.1 Hello World 컨테이너 실행하기 docker run busybox echp &quot;Hello world&quot; 백그라운드에 일어난 동작 이해하기 docker run 명령을 수행했을 떄 일어나는 일들 2.1.2 간단한 node.js 애플리...</p></div></div></a></div><div class="card"> <a href="/posts/devlog-platform-kubernetes-in-action3/"><div class="card-body"> <em class="small" data-ts="1596443640" data-df="ll" > Aug 3, 2020 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[kubernetes-in-action] 3. 파드 : 쿠버네티스에서 컨테이너 실행</h3><div class="text-muted small"><p> 3. 파드 : 쿠버네티스에서 컨테이너 실행 3.1 파드 소개 파드는 함께 배치된 컨테이너 그룹이며, 쿠버네티스의 기본 빌딩 블록. 컨테이너를 개별적으로 배포하기보다는 컨테이너를 가진 파드를 배포하고, 운영한다. 무조건 2개 이상을 컨테이너를 포함시키라는 의미는 아니고 일반적으로는 하나의 컨테이너만 포함된다. 파드의 핵심은 파드가 여러 ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/devlog-platform-kubernetes-in-action5/" class="btn btn-outline-primary" prompt="Older"><p>[kubernetes-in-action] 5. 서비스 : 클라이언트가 파드를 검색하고 통신을 가능하게 함.</p></a> <a href="/posts/devlog-platform-kubernetes-in-action7/" class="btn btn-outline-primary" prompt="Newer"><p>[kubernetes-in-action] 7. 컨피그맵과 시크릿 : 애플리케이션 설정</p></a></div><div id="disqus_thread" class="pt-2 pb-2"><p class="text-center text-muted small">Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script type="text/javascript"> var disqus_config = function () { this.page.url = 'https://sungsu9022.github.io/posts/devlog-platform-kubernetes-in-action6/'; this.page.identifier = '/posts/devlog-platform-kubernetes-in-action6/'; }; /* Lazy loading */ var disqus_observer = new IntersectionObserver( function (entries) { if (entries[0].isIntersecting) { (function () { var d = document, s = d.createElement('script'); s.src = 'https://sungsu-parks-tech-blog.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); disqus_observer.disconnect(); } }, { threshold: [0] } ); disqus_observer.observe(document.querySelector('#disqus_thread')); /* Auto switch theme */ function reloadDisqus() { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* Disqus hasn't been loaded */ if (typeof DISQUS === 'undefined') { return; } if (document.readyState == 'complete') { DISQUS.reset({ reload: true, config: disqus_config }); } } } if (document.querySelector('.mode-toggle')) { window.addEventListener('message', reloadDisqus); } </script></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/spark/">Spark</a> <a class="post-tag" href="/tags/infra/">Infra</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/kubernetes-in-action/">kubernetes-in-action</a> <a class="post-tag" href="/tags/kubernetes/">kubernetes</a> <a class="post-tag" href="/tags/elasticsearch/">Elasticsearch</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/effective-java/">Effective Java</a> <a class="post-tag" href="/tags/hands-on-reactive-programming-in-spring-5/">Hands-On Reactive Programming in Spring 5</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://twitter.com/sungsu9022dev">sungsu9022</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0">Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></div></footer><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-145894105-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-145894105-1'); }); </script>
