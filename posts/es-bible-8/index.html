<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.3.3" /><meta property="og:title" content="[엘라스틱서치 바이블] 8. 엘라스틱서치의 내부 동작 상세" /><meta name="author" content="sungsu park" /><meta property="og:locale" content="en" /><meta name="description" content="[엘라스틱서치 바이블] 8. 엘라스틱서치의 내부 동작 상세 ES의 기본 구조와 핵심 동작 양상, 주요 기능, 서비스 환경을 구축하고 운영하며 장애에 대응하는 방법을 학습한것만으로도 ES를 활용한 개발에 큰 어려움이 없을것이다. 다만, 고도화가 필요하다면, 내부 동작을 구체적으로 이해하는것이 중요하다." /><meta property="og:description" content="[엘라스틱서치 바이블] 8. 엘라스틱서치의 내부 동작 상세 ES의 기본 구조와 핵심 동작 양상, 주요 기능, 서비스 환경을 구축하고 운영하며 장애에 대응하는 방법을 학습한것만으로도 ES를 활용한 개발에 큰 어려움이 없을것이다. 다만, 고도화가 필요하다면, 내부 동작을 구체적으로 이해하는것이 중요하다." /><link rel="canonical" href="https://sungsu9022.github.io/posts/es-bible-8/" /><meta property="og:url" content="https://sungsu9022.github.io/posts/es-bible-8/" /><meta property="og:site_name" content="Sungsu’s Tech Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-02-03T21:45:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[엘라스틱서치 바이블] 8. 엘라스틱서치의 내부 동작 상세" /><meta name="twitter:site" content="@sungsu9022dev" /><meta name="twitter:creator" content="@sungsu park" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"sungsu park"},"dateModified":"2024-02-03T21:45:00+09:00","datePublished":"2024-02-03T21:45:00+09:00","description":"[엘라스틱서치 바이블] 8. 엘라스틱서치의 내부 동작 상세 ES의 기본 구조와 핵심 동작 양상, 주요 기능, 서비스 환경을 구축하고 운영하며 장애에 대응하는 방법을 학습한것만으로도 ES를 활용한 개발에 큰 어려움이 없을것이다. 다만, 고도화가 필요하다면, 내부 동작을 구체적으로 이해하는것이 중요하다.","headline":"[엘라스틱서치 바이블] 8. 엘라스틱서치의 내부 동작 상세","mainEntityOfPage":{"@type":"WebPage","@id":"https://sungsu9022.github.io/posts/es-bible-8/"},"url":"https://sungsu9022.github.io/posts/es-bible-8/"}</script><title>[엘라스틱서치 바이블] 8. 엘라스틱서치의 내부 동작 상세 | Sungsu's Tech Blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Sungsu's Tech Blog"><meta name="application-name" content="Sungsu's Tech Blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/personal/sunny.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">Sungsu's Tech Blog</a></div><div class="site-subtitle font-italic">Java/Kotlin Spring, Back-end</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/sungsu9022" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/sungsu9022dev" aria-label="twitter" target="_blank" rel="noopener noreferrer"> <i class="fab fa-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['sungsu9022','naver.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[엘라스틱서치 바이블] 8. 엘라스틱서치의 내부 동작 상세</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>[엘라스틱서치 바이블] 8. 엘라스틱서치의 내부 동작 상세</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1706964300" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Feb 3, 2024 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href=""></a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="8695 words"> <em>48 min</em> read</span></div></div></div><div class="post-content"><h1 id="엘라스틱서치-바이블-8-엘라스틱서치의-내부-동작-상세">[엘라스틱서치 바이블] 8. 엘라스틱서치의 내부 동작 상세</h1><ul><li>ES의 기본 구조와 핵심 동작 양상, 주요 기능, 서비스 환경을 구축하고 운영하며 장애에 대응하는 방법을 학습한것만으로도 ES를 활용한 개발에 큰 어려움이 없을것이다.<li>다만, 고도화가 필요하다면, 내부 동작을 구체적으로 이해하는것이 중요하다.</ul><h2 id="81-엘라스틱서치의-데이터-분산-처리-과정"><span class="mr-2">8.1 엘라스틱서치의 데이터 분산 처리 과정</span><a href="#81-엘라스틱서치의-데이터-분산-처리-과정" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>데이터 읽기와 쓰기 작업 요청이 들어왔을떄 ES 내부가 어떤 단계를 거쳐 동작하는지 살펴본다.</ul><h3 id="811-쓰기-작업-시-엘라스틱서치-동작과-동시성-제어"><span class="mr-2">8.1.1 쓰기 작업 시 엘라스틱서치 동작과 동시성 제어</span><a href="#811-쓰기-작업-시-엘라스틱서치-동작과-동시성-제어" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>쓰기 작업은 조정 단계(coordination stage), 주 샤드 단계(primary stage), 복제 단계(replica stage)의 3단계로 수행된다.</ul><p><a href="https://github.com/sungsu9022/study/assets/6982740/d7055cb1-d648-423d-93f7-78f8ec9497fd" class="popup img-link "><img width="429" alt="스크린샷 2024-02-04 오후 5 13 53" data-src="https://github.com/sungsu9022/study/assets/6982740/d7055cb1-d648-423d-93f7-78f8ec9497fd" class="lazyload" data-proofer-ignore></a></p><h4 id="조정-단계"><span class="mr-2">조정 단계</span><a href="#조정-단계" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>먼저 라우팅을 통해 어느 샤드에 작업해야 할지 파악하고, 적절한 주 샤드를 찾아 요청을 넘겨준다.</ul><h4 id="주-샤드-단계"><span class="mr-2">주 샤드 단계</span><a href="#주-샤드-단계" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>주 샤드에 작업 요청이 넘어오면 요청이 문제 없는지 검증하고, 쓰기 작업을 수행한다.<li>작업이 완료되면 각 본제본 샤드로 요청을 넘긴다.</ul><h4 id="복제-단계"><span class="mr-2">복제 단계</span><a href="#복제-단계" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>마스터 노드는 작업을 복제받을 샤드 목록을 관리하는데 이를 in-sync 복제본이라 하고, 이 샤드는 주 샤드에게 받은 요청을 로컬에서 수행하고, 주 샤드에게 작업이 완료됐음을 보고하는데 이 과정을 복제 단계라고 한다.</ul><h4 id="각-단계의-종료-시점"><span class="mr-2">각 단계의 종료 시점</span><a href="#각-단계의-종료-시점" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>각 단계의 실행은 조정 -&gt; 주 샤드 -&gt; 복제 단계로 실행되지만 종료는 역순이다.<li>복제 단계가 완료되어 주 샤드에게 응답을 모두 보내야 주 샤드 단계가 종료된다. 조정 단계도 주 샤드 단계에서 최초 요청을 받아 전달했던 노드에게 작업 완료결과를 보내야 조정 단계가 종료된다.</ul><h4 id="쓰기-작업의-전체-흐름"><span class="mr-2">쓰기 작업의 전체 흐름</span><a href="#쓰기-작업의-전체-흐름" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><a href="https://github.com/sungsu9022/study/assets/6982740/eb0a124f-100b-4d17-95a5-e6ac11fe2a21" class="popup img-link "><img width="600" alt="스크린샷 2024-02-04 오후 5 25 36" data-src="https://github.com/sungsu9022/study/assets/6982740/eb0a124f-100b-4d17-95a5-e6ac11fe2a21" class="lazyload" data-proofer-ignore></a></p><h4 id="낙관적-동시성-제어"><span class="mr-2">낙관적 동시성 제어</span><a href="#낙관적-동시성-제어" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>주 샤드 단계에서 작업을 각 복제본 샤드에 병렬적으로 보내는데, 이때 여러 작업을 병렬적으로 보내면 메시지 순서의 역전이 일어날 수 있다. ES에서는 낙관적 동시성 제어를 통해 이를 처리한다.</ul><p><a href="https://github.com/sungsu9022/study/assets/6982740/0b6c1fb0-1e15-4e15-b39c-3e136fd9c2c3" class="popup img-link "><img width="600" alt="스크린샷 2024-02-04 오후 5 24 47" data-src="https://github.com/sungsu9022/study/assets/6982740/0b6c1fb0-1e15-4e15-b39c-3e136fd9c2c3" class="lazyload" data-proofer-ignore></a></p><ul><li>변경 내용이 복제본 샤드에 완전히 적용되기 전에 다른 클라이언트로부터 주 샤드에 같은 문서의 필드 값을 변경하는 요청이 발생하면 분산시스템 특성상 어떤 요청이 먼저 본제본 샤드로 들어올지는 보장할 수 없다.<li>ES에서는 이러한 동시성 문제를 방지하기 위해 <code class="language-plaintext highlighter-rouge">_seq_no</code>가 존재한다.<ul><li><code class="language-plaintext highlighter-rouge">_seq_no</code>는 각 주 샤드마다 들고 있는 시퀀스 숫자값이며, 매 작업마다 1씩 증가한다.<li>ES에서 문서를 색인할 때 이 값을 함게 저장하는데, eS에서는 이 값을 역전 시키는 변경을 허용하지 않음으로써 요청 순서의 역전 적용을 방지한다.</ul><li>주 샤드를 들고 있는 노드에 문제가 발생하여 해당 노드가 클러스터에서 빠지는 경우에 대한 처리를 위한 방안도 존재한다.<ul><li><code class="language-plaintext highlighter-rouge">_primary_term</code>이라는 이전 주샤드에서 수행했던 작업과 새로 임명된 주 샤드에서 수행했던 작업을 구분하기 위한 값이 존재하고, 주 샤드가 새로 지정될 때 1씩 값을 증가시킨다.</ul><li>ES에서는 이러한 방법으로 낙관적 동시성 제어(optimistic concurrency control)을 수행한다.</ul><h4 id="_seq_no와--primary_term이-배정되는-과정"><span class="mr-2"><code class="language-plaintext highlighter-rouge">_seq_no</code>와 <code class="language-plaintext highlighter-rouge">primary_term</code>이 배정되는 과정</span><a href="#_seq_no와--primary_term이-배정되는-과정" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre>### 인덱스 생성
PUT /concurrency_test
Host: localhost:9200
Content-Type: application/json

{
  "settings": {
    "number_of_shards": 2
  }
}

### 문서 색인
PUT /concurrency_test/_doc/1
Host: localhost:9200
Content-Type: application/json

{
  "views": 1
}
</pre></table></code></div></div><div class="language-json highlighter-rouge"><div class="code-header"> <span data-label-text="JSON"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="p">{</span><span class="w">
  </span><span class="nl">"_index"</span><span class="p">:</span><span class="w"> </span><span class="s2">"concurrency_test"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"_id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"_version"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
  </span><span class="nl">"result"</span><span class="p">:</span><span class="w"> </span><span class="s2">"created"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"_shards"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
	</span><span class="nl">"total"</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w">
	</span><span class="nl">"successful"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
	</span><span class="nl">"failed"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"_seq_no"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
  </span><span class="nl">"_primary_term"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">_seq_no</code>는 주 샤드마다 따로 매긴다. 데이터가 다른 샤드에 색인되면 <code class="language-plaintext highlighter-rouge">_seq_no</code>는 0부터 다시 매기는것을 확인할 수 있다.<ul><li>로컬에서 테스트할때는 모두 같은 샤드에 색인되는것까지만 확인하긴 했음.</ul></ul><h4 id="if_primary_term-if_seq_no"><span class="mr-2">if_primary_term=, if_seq_no</span><a href="#if_primary_term-if_seq_no" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>PUT /concurrency_test/_doc/1?if_primary_term=1&amp;if_seq_no=1
Host: localhost:9200
Content-Type: application/json

{
  "views": 3
}
</pre></table></code></div></div><ul><li>문서 색인시 지정한 값과 같은 seq_no, primary_term인 경우에만 색인 작업이 실행되도록 할 수 있다.</ul><h4 id="버전_version"><span class="mr-2">버전(_version)</span><a href="#버전_version" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>위 색인 테스트에서 <code class="language-plaintext highlighter-rouge">_version</code>이라는 값이 증가하는 것도 확인 할 수 있는데, 이는 <code class="language-plaintext highlighter-rouge">_seq_no</code>와 <code class="language-plaintext highlighter-rouge">_primary_term</code> 처럼 동시성을 제어하기 위한 메타데이터로 모든 무서마다 붙는다.<li>기본적으로 1부터 시작해서 업데이트나 삭제 작업을 수행하면 1씩 증가한다.<li><code class="language-plaintext highlighter-rouge">_seq_no</code>나 <code class="language-plaintext highlighter-rouge">_primary_term</code> 과 다른 점은 클라이언트가 문서의 <code class="language-plaintext highlighter-rouge">_version</code> 값을 직접 지정할 수 있다는 점이다.<ul><li>version_type을 external / external_gte로 설정하면 클라이언트가 직접 <code class="language-plaintext highlighter-rouge">_version</code>을 지정해 색인할 수 있다.</ul></ul><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre>### 버전
PUT /concurrency_test/_doc/10
Host: localhost:9200
Content-Type: application/json

{
  "views": 0
}

### 버전 external 지정
PUT /concurrency_test/_doc/10?version=15&amp;version_type=external
Host: localhost:9200
Content-Type: application/json

{
  "views": 1
}
</pre></table></code></div></div><div class="language-json highlighter-rouge"><div class="code-header"> <span data-label-text="JSON"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="p">{</span><span class="w">
  </span><span class="nl">"_index"</span><span class="p">:</span><span class="w"> </span><span class="s2">"concurrency_test"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"_id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"10"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"_version"</span><span class="p">:</span><span class="w"> </span><span class="mi">15</span><span class="p">,</span><span class="w">
  </span><span class="nl">"result"</span><span class="p">:</span><span class="w"> </span><span class="s2">"updated"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"_shards"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
	</span><span class="nl">"total"</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w">
	</span><span class="nl">"successful"</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w">
	</span><span class="nl">"failed"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"_seq_no"</span><span class="p">:</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w">
  </span><span class="nl">"_primary_term"</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></pre></table></code></div></div><ul><li>version은 long 범위 이내 정수로 지정할 수 있다.<li>마지막 버전보다 낮은 값으로 재색인하려는 경우 version_conflict_engine_exception 이 발생한다.<li>version_type은 internal / external(external_gt) / external_gte가 있다.<ul><li>internal은 별도로 지정하지 않고 ES에서 자동으로 매겨주는 타입이다.<li>external은 기존 문서의 버전보다 더 클 떄에만 색인이 수행된다.<li>external_gte는 기존 문서의 버전보다 새 문서의 버전이 더 크거나 같을 떄에만 색인이 수행된다.</ul></ul><h3 id="812-읽기-작업시-엘라스틱서치-동작"><span class="mr-2">8.1.2 읽기 작업시 엘라스틱서치 동작</span><a href="#812-읽기-작업시-엘라스틱서치-동작" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>클라이언트로부터 읽기 작업을 요청받은 조정도느는 라우팅을 통해 적절한 샤드를 찾아 요청을 넘긴다.<ul><li>쓰기와 다르게 주 샤드가 아니라 복제본 샤드로 요청이 넘어갈 수 있다.<li>요청을 넘겨받은 각 샤드는 로컬에서 읽기 작업을 수행한 뒤 그 결과를 조정 노드로 돌려준다.<li>조정 노드는 이 결과를 모아서 클라이언트에 응답한다.</ul></ul><p><a href="https://github.com/sungsu9022/study/assets/6982740/ed32647c-9223-41a7-b062-1ae336e598d5" class="popup img-link "><img width="600" alt="스크린샷 2024-02-04 오후 6 05 36" data-src="https://github.com/sungsu9022/study/assets/6982740/ed32647c-9223-41a7-b062-1ae336e598d5" class="lazyload" data-proofer-ignore></a></p><ul><li>이때, 주 샤드에는 색인이 완료됐지만, 특정 본제본에는 반영이 완료되지 않은 상탤태로 데이터를 읽을 수 있다는 점을 염두에 둬야 한다.</ul><h3 id="813-체크포인트와-샤드-복구-과정"><span class="mr-2">8.1.3 체크포인트와 샤드 복구 과정</span><a href="#813-체크포인트와-샤드-복구-과정" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>문제가 생겨서 특정 노드가 재기동되었다면 그 노드가 들고 있던 샤드에 복구 작업이 진행되는데, 이 과정에서 복구 중인 샤드가 현재 주 샤드의 내용과 일치하는지를 파악할 필요가 있다.<ul><li>재기동되는 동안 주 샤드에 색인 작업이 있었다면, 그 내용을 복구중인 샤드에도 반영해야 할 것이다.<li>문제가 발생했던 노드가 주 샤드를 들고 있었다면 다운타임 중에 선출된 주 샤드가 미처 반영하지 못한 작업 내용이 복구 중인 샤드에 포함돼 있을수도 있다.<li>ES에서는 이런 부분을 고려하여 샤드 복구를 수행한다.</ul></ul><h4 id="수행-과정과-체크포인트-업데이트-흐름"><span class="mr-2">수행 과정과 체크포인트 업데이트 흐름</span><a href="#수행-과정과-체크포인트-업데이트-흐름" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>ES에서는 앞서 다루었던 <code class="language-plaintext highlighter-rouge">_primary_term</code>과 <code class="language-plaintext highlighter-rouge">_seq_no</code> 을 조합하면 샤드와 샤드 사이에 어떤 반영 차이점이 있는지 알 수 있다.<li>각 샤드는 로컬에 작업을 수행하고 나면 몇번 작업까지 순차적으로 빠짐없이 수행을 완료했는지를 로컬 체크포인트로 기록한다.<li>복제본 샤드는 로컬 체크포인트 값이 업데이트되면 이를 주 샤드에 보고한다.<li>주 샤드는 갹 복제본 샤드로부터 받은 로컬 체크포인트를 비교하여 가장 낮은 값을 글로벌 체크포인트 값으로 기록하고, 체크포인트를 비교하여 가장 낮은 값을 글로벌 체크 포인트 값으로 기록한다.</ul><p><a href="https://github.com/sungsu9022/study/assets/6982740/045292d2-5b31-4fa8-8ea4-598e487a82b5" class="popup img-link "><img width="600" alt="스크린샷 2024-02-04 오후 6 09 49" data-src="https://github.com/sungsu9022/study/assets/6982740/045292d2-5b31-4fa8-8ea4-598e487a82b5" class="lazyload" data-proofer-ignore></a></p><h4 id="복구-방식"><span class="mr-2">복구 방식</span><a href="#복구-방식" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>문제가 발생해 샤드를 복구해야 할 경우 ES는 샤드 간의 글로벌 체크포인트를 비교한다.<li>주 샤드와 보제본 샤드의 글로벌 체크포인트가 같다면 이 샤드는 추가 복구 작업이 필요없다.<li>글로벌 체크 포인트가 차이가 난다면 두 샤드 간 체크포인트를 확인해서 필요한 작업만 재처리하여 복구한다.<li>재처리할 내용을 추적하는 매커니즘을 ES에서는 샤드 이력 보존(shard history retention leases)라고 부른다.<ul><li><code class="language-plaintext highlighter-rouge">index.soft_deletes.retention_lease.period</code> 기간을 설정하여 보존 기간을 관리할수 있고, default 12시간이다.<li>이 기간을 넘겨서 샤드 이력이 만료된 이후 수행되는 복구 작업에는 작업 재처리를 이용하지 않고, 세그먼트 파일을 통째로 복사하는 방법을 사용한다.</ul></ul><h2 id="82-엘라스틱서치의-검색-동작-상세"><span class="mr-2">8.2 엘라스틱서치의 검색 동작 상세</span><a href="#82-엘라스틱서치의-검색-동작-상세" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>ES 레벨에서 어떻게 검색을 수행하는지 각 샤드 레벨, 즉 루씬 레벨에서는 매칭되는 문서를 어떻게 판정하고 점수를 계산하는지, 캐시는 어떻게 동작하는지 그 내부를 깊게 살펴보자.</ul><h3 id="821-엘라스틱서치-검색-동작-흐름"><span class="mr-2">8.2.1 엘라스틱서치 검색 동작 흐름</span><a href="#821-엘라스틱서치-검색-동작-흐름" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="es-검색-동작-흐름-개괄"><span class="mr-2">ES 검색 동작 흐름 개괄</span><a href="#es-검색-동작-흐름-개괄" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><blockquote><p>검색 뿐만 아니라 다른 API도 아래와 같은 기본적인 흐름을가지고 있음.</p></blockquote><p><a href="https://github.com/sungsu9022/study/assets/6982740/95c92c17-1617-4152-b657-5013744c7760" class="popup img-link "><img width="400" alt="스크린샷 2024-02-04 오후 6 22 14" data-src="https://github.com/sungsu9022/study/assets/6982740/95c92c17-1617-4152-b657-5013744c7760" class="lazyload" data-proofer-ignore></a></p><ul><li>RestSearchAciton : REST 요청을 ES 내부에서 사용할 요청으로 변경하여 다음 단계로 요청하는 과정<li>TransportSearchAction : 검색 요청과 현재 클러스터 상태를 분석해 상황에 맞는 적절한 검색 방법과 대상을 확정하고 검색 작업을 다음 단계로 넘기는 과정<li>Query Phase : 쿼리에 매칭되는 상위 문서들을 각 샤드들이 판단하여 조정 노드로 반환하는 과정<li>Fetch Phase : 각 샤드의 검색 결과를 받아 fetch를 수행할 문서를 확정하는 과정</ul><h4 id="es-검색-동작-흐름-상세"><span class="mr-2">ES 검색 동작 흐름 상세</span><a href="#es-검색-동작-흐름-상세" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><a href="https://github.com/sungsu9022/study/assets/6982740/00a0ded5-100d-4cba-ab64-4c5f1d8e2e6a" class="popup img-link "><img width="407" alt="스크린샷 2024-02-04 오후 6 29 48" data-src="https://github.com/sungsu9022/study/assets/6982740/00a0ded5-100d-4cba-ab64-4c5f1d8e2e6a" class="lazyload" data-proofer-ignore></a></p><h5 id="transportsearchaction"><span class="mr-2">TransportSearchAction</span><a href="#transportsearchaction" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><ul><li>다양한 방법을 통해 여러 샤드 중에서 어떤 샤드에 우선해서 요청을 보낼것인지 순서를 확정한다.<li>우선순위가 가장 높은 샤드 하나에 요청을 보냈을 때 실패할 수도 있으므로 요청 순서 목록을 작성한다. (ShardIterator)<li>어떤 노드와 샤드를 우선해서 검색할 것인지 지정하는 매개변수 <code class="language-plaintext highlighter-rouge">preference</code> 값을 먼저 읽고 처리한다.<li><code class="language-plaintext highlighter-rouge">preference</code>가 지정되지 않았다면 ES는 해당 샤드를 가진 노드 중 적절한 노드를 선정한다. 조정 노드에서 보낸 이전 요청에 대한 응답 속도나 이전 검색 요청에서 시간이 얼마나 소요됐는지 등 그간의 통계 데이터와 현재 검색 스레드 풀 상황이 어떠한지를 고려해 가장 응답을 빨리 돌려줄것으로 예상되는 노드를 보통 선정한다.<li>만약 pit가 지정됐다면 처음부터 pit 값으로 검색 문맥을 가져오고 거기에서 검색 대상 인덱스와 샤드를 가져온다.</ul><h5 id="preference"><span class="mr-2">preference</span><a href="#preference" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><blockquote><p><a href="https://velog.io/@khj2872/Elasticsearch-preference-query-parameter">preference 관련 트래블슈팅 사례</a></p></blockquote><ul><li><code class="language-plaintext highlighter-rouge">_only_local</code> : 로컬에 들고 있는 샤드만을 대상으로 검색을 수행한다.<li><code class="language-plaintext highlighter-rouge">_local</code> : 가능하면 로컬에 들고 있는 샤드를 우선으로 검색을 수행한다. 불가능하다면 다른 노드의 샤드를 대상으로 지정한다.<li><code class="language-plaintext highlighter-rouge">_only_nodes:&lt;node-id&gt;, &lt;node-id&gt;</code> : 지정한 노드 ID가 들고 있는 샤드를 대상으로만 검색을 수행한다.<li><code class="language-plaintext highlighter-rouge">_prefer_nodes:&lt;node-id&gt;,&lt;node-id&gt;</code> : 지정한 노드 ID가 들고 있는 샤드를 우선해서 검색한다.<li><code class="language-plaintext highlighter-rouge">_shards:&lt;shard&gt;, &lt;shard&gt;</code> : 샤드 번호를 직접 지정해 해당 샤드 대상으로만 검색을 수행한다.<li><code class="language-plaintext highlighter-rouge">custom-string</code> : <code class="language-plaintext highlighter-rouge">_</code>로 시작하지 않는 문자열 지정으로, 지정한 문자열의 해시 값으로 노드 우선순위를 지정한다. 같은 노드가 요청을 받도록 해서 캐시를 최대한 활용하고자 할 떄 이방법을 사용한다.</ul><h5 id="canmatchprefiltersearchphase"><span class="mr-2">CanMatchPreFilterSearchPhase</span><a href="#canmatchprefiltersearchphase" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><ul><li>검색 요청의 search_type이 query_then_fetch이고, 몇몇 특정 조건을 만족하면 ES는 본격적인 검색 작업에 들어가기 전에 이 과정을 거치며 몇가지 최적화를 수행한다.<li>검색 대상의 샤드 수가 128개를 초과하거나 검색 대상이 읽기 전용 인덱스를 포함하거나, 첫번째 정렬 기준에 색인된 필드가 지정된 경우 수행된다.<li>검색 대상 샤드에서 주어진 쿼리로 단 하나의 문서라도 매치될 가능성이 있는지 사전에 점검을 수행해 확실히 검색 대상이 될 필요가 없는 샤드를 사전에 제거한다.<li>인덱스의 메타데이터를 이용해 타임스탬프 필드 범위상 매치되는 문서가 확실히 없는지를 체크한다거나 색인된 필드가 지정되어 있으면 각 샤드의 최솟값과 최대값을 가지고 샤드를 정렬해 상위에 올라올 문서를 보유한 샤드가 먼저 수행되도록 최적화하는 등 다양한 방법이 사용된다.</ul><h5 id="abstractsearchasyncaction"><span class="mr-2">AbstractSearchAsyncAction</span><a href="#abstractsearchasyncaction" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><ul><li>search_type의 기본값인 query_then_fetch로 수행하는 경우 각 샤드에서 검색 쿼리를 수행하고, 매치된 상위 문서를 수집할 때 유사도 점수 계산을 끝내는 가장 일반적인 형태의 검색인데, 이 경우 이 단계에서 전체적인 흐름을 제어한다.(SeachQueryThenFetchAsyncAction)<li>search_type을 dfs_query_then_fetch로 지정하면 모든 샤드로부터 사전에 추가 정보를 모아 정확한 유사도 점수를 계산한다.<ul><li>정확도는 올라가지만 성능은떨어진다.(SearchDfsQueryThenFetchAsyncAction)<li>dfs : distributed frequency search</ul></ul><h5 id="searchphase"><span class="mr-2">SearchPhase</span><a href="#searchphase" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>-조정 노드에서 수행하는 작업과 각 샤드 레벨에서 수행하는 작업을 구분해서 봐야 한다.</p><ul><li>QueryPhase, DfsPhase, FetchPhase 등은 각 샤드에서 수행되고 나머지는 조정노드에서 수행된다.</ul><h5 id="searchdfsquerythenfetchasyncaction"><span class="mr-2">SearchDfsQueryThenFetchAsyncAction</span><a href="#searchdfsquerythenfetchasyncaction" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><ul><li>점수 계산에 사용할 추가 정보를 각 샤드에서 가져오기 위해 샤드별 요청을 만들어서 분산 전송한다.<li>이 과정에서 각 샤드는 검색 쿼리에 매치되는 텀이나 문서 빈도(document frequency), 여러 통계 데이터 등을 구해 반환한다.<li>이후 조정노드에서 DfsQueryPhase를 수행한다.</ul><h5 id="dfsqueryphase"><span class="mr-2">DfsQueryPhase</span><a href="#dfsqueryphase" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><ul><li>각 샤드에서 보낸 DfsPhase 작업 결과로부터 샤드별 본 검색 요청을 만들어 다시 각 노드로 분산 전송한다.<li>QueryPhase에서 본격적인 쿼리 매치 작업을 수행하고 이 작업 결과를 수신하면 FetchSearchPhase로 넘어간다.</ul><h5 id="searchquerythenfetchasyncaction"><span class="mr-2">SearchQueryThenFetchAsyncAction</span><a href="#searchquerythenfetchasyncaction" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><ul><li>query_then_fetch search_type인 경우 사전 작업 없이 바로 샤드별 검색 요청을 만들어 전송한다.<li>샤드별 결과를 수신하면 FetchSearchPhase로 넘어간다.</ul><h5 id="queryphase"><span class="mr-2">QueryPhase</span><a href="#queryphase" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><ul><li>이 단계에서는 샤드 요청이 캐시 가능한 요청인지 확인하고, 캐시 가능한 요청이라면 캐시에서 값을 불러와 바로 응답을 반환한다.(샤드 레벨 저장 캐시)<li>캐시에 값이 없다면 QueryPhase의 주 작업을 수행하고 캐시에 결과를 저장한다.<li>QueryPhase에서는 크게 검색, 제안(suggest), 집계의 세 작업을 수행한다.<li>제안(suggest) 작업은 오타 교정이나 자동완성 등에 사용하는 기능이다.</ul><h5 id="fetchsearchphase와-fetchphase"><span class="mr-2">FetchSearchPhase와 FetchPhase</span><a href="#fetchsearchphase와-fetchphase" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><ul><li>각 샤드가 수행한 QueryPhase 작업의 결과가 조정 노드에 모이면 FetchSearchPhase로 넘어간다.<li>FetchSearchPhase 단계에서는 각 샤드에 요청할 fetch 요청을 생성해 분산 전송한다.<li>FetchPhase에서는 요청에 지정한 번호의 문서의 내용을 실제로 읽어서 반환한다.<li>각 샤드의 FetchPhase의 작업 결과가 조정 노드에 모이면 ExpandSearchPhase로 넘어간다.</ul><h5 id="fetchsubphase"><span class="mr-2">FetchSubPhase</span><a href="#fetchsubphase" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><ul><li>FetchSubPhase는 문서 내용을 읽어 SearchHit을 만드는 과정에서 수행하는 여러 하위 작업을 처리하는 단계이다.<li>커스텀 플러그인을 통해 직접 만든 FetchSubPhase를 등록할 수도 있다.<li>_soruce를 읽거나 _score을 다시 계산하거나, 검색 수행 중간 과정과 부분 유사도 점수를 상세 설명하는 _explanation을 만드는 과정들이 포함된다.</ul><h5 id="expandsearchphase"><span class="mr-2">ExpandSearchPhase</span><a href="#expandsearchphase" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><blockquote><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/collapse-search-results.html">collapse를 이용한 검색 축소</a></p></blockquote><ul><li>ExpandSearchPhase에서는 필드 collapse을 수행한다.<ul><li>이는 지정한 필드 값을 기준으로 검색 결과를 그룹으로 묶은 뒤 그 안에서 다른 기준으로 상위 문서를 지정한 개수만큼 뽑을 떄 사용하는 특수한 기능이다.<li>필드 collapse을 수행하기 위해 본 검색의 hit 수만큼 새 검색 요청을 만들어서 로컬에 전송하고, 조정 노드 자신이 이를 받는다.</ul><li>이 과정을 마무리하면 결과를 모아서 최종 검색 결과를 만들어 반환하고 검색 작업을 조욜한다.<ul><li>필드 collapse을 사용하지 않는다면 바로 응답을 반환한다.</ul></ul><h3 id="822-루씬-쿼리의-매칭과-스코어링-과정"><span class="mr-2">8.2.2 루씬 쿼리의 매칭과 스코어링 과정</span><a href="#822-루씬-쿼리의-매칭과-스코어링-과정" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>위에서 학습한 QueryPhase에서 쿼리에 매칭되는 상위 문서를 수집하는 작업은 각 샤드 레벨, 즉 루씬 레벨에서 수행하는 작업이다.<li>루씬이 어떻게 검색 작업을 수행하는지 흐름을 이해하면 어떤 쿼리가 무거운 쿼리이고 문제가 되는 경우를 이해하기 쉽다.</ul><p><a href="https://github.com/sungsu9022/study/assets/6982740/734db3d4-a747-4b11-87d1-7c9b2009a482" class="popup img-link "><img width="456" alt="스크린샷 2024-02-04 오후 7 30 30" data-src="https://github.com/sungsu9022/study/assets/6982740/734db3d4-a747-4b11-87d1-7c9b2009a482" class="lazyload" data-proofer-ignore></a></p><h4 id="indexsearcher"><span class="mr-2">IndexSearcher</span><a href="#indexsearcher" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>IndexSearcher 는 루씬 인덱스 내의 문서를 검색할 때 사용하는 클래스</ul><h4 id="querybuilder"><span class="mr-2">QueryBuilder</span><a href="#querybuilder" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>ES 레벨의 쿼리를 정의하는 인터페이스로 쿼리 이름, DSL 파싱, 직렬화 여부 등을 정의한다.</ul><h4 id="query"><span class="mr-2">Query</span><a href="#query" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>루씬 쿼리를 정의하는 추상클래스</ul><h4 id="weight"><span class="mr-2">Weight</span><a href="#weight" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>Query 내부 동작을 구현하는 추상클래스로, IndexSearcher에 의존ㄴ성 있는 작업이나 상태를 담당한다.</ul><h4 id="scorer"><span class="mr-2">Scorer</span><a href="#scorer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>유사도 점수 계싼을 담당하는 추상 클래스로</ul><h4 id="bulkscorer"><span class="mr-2">BulkScorer</span><a href="#bulkscorer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>여러 문서를 대상으로 한 번에 유사도 점수를 계산하는 추상 클래스<li>Weight의 BulkScorer 메소드를 따로 오버라이드하지 않았다면 기본 구현인 DefaultBulkScorer 클래스를 반환하여 사용한다.</ul><h4 id="docidsetiterator"><span class="mr-2">DocIdSetIterator</span><a href="#docidsetiterator" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>ocIdSetIterator는 매치된 문서의 순회를 담당하는 추상 클래스이다.</ul><p><a href="https://github.com/sungsu9022/study/assets/6982740/217af694-49e2-42f7-9d0d-9439063aca93" class="popup img-link "><img width="449" alt="스크린샷 2024-02-04 오후 7 37 47" data-src="https://github.com/sungsu9022/study/assets/6982740/217af694-49e2-42f7-9d0d-9439063aca93" class="lazyload" data-proofer-ignore></a></p><ul><li>hello 라는 질의어로 term 쿼리를 수행했다고 가정해보면 루씬은 해당 필드의 역색인을 읽어 어떤 문서가 hello term을 가지고 있는지 목록을 불러오고, 이 목록을 DocIdSetIterator로 순회한다.<li>일반적인 경우는 next로 순회할 수 있으나, 일부 문서들을 수집 후보에서 건너뛸 수 있다거나 한 경우 advance(target)을 호출하여 순회한다.</ul><h4 id="twophaseiterator"><span class="mr-2">TwoPhaseIterator</span><a href="#twophaseiterator" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>매치 여부를 판단하는 작업이 무거운 쿼리의 매치 작업을 두 개 페이즈로 나누어 진행하도록 하는 추상 클래스이다.<li>비용이 저렴한 간략한 매치를 먼저 수행해 후보를 좁히고 난 뒤 문서 수집 과정에서 최종 매치를 수행한다.</ul><h4 id="collector-leaftcollector"><span class="mr-2">Collector, LeaftCollector</span><a href="#collector-leaftcollector" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>Collector는 검색 결과를 수집하는 동작을 정의하는 인터페이스이다.<li>유사도 점수나 정렬 기준 등을 계산하거나 확인하며, 상위 결과를 수집하는 동작 등을 수행한다.</ul><h4 id="bool-쿼리의-검색-동작-순서와-docidsetiterator-순회"><span class="mr-2">bool 쿼리의 검색 동작 순서와 DocIdSetIterator 순회</span><a href="#bool-쿼리의-검색-동작-순서와-docidsetiterator-순회" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>bool 쿼리는 must, filter, must_not, should 절 하위에 다양한 쿼리르 갖고 있는데, 이 중 어떤 쿼리를 먼저 수행된다는 알기 쉬운 정해진 규칙이 없다. 이를 루씬의 주요 동작과 연결시켜 상세히 알아보자.</ul><h5 id="rewrite-cost"><span class="mr-2">rewrite, cost</span><a href="#rewrite-cost" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><ul><li>ES는 검색 요청을 받으면 내부적으로 쿼리를 루씬의 여러 쿼리로 쪼갠 뒤 조합해 재작성한다.(<code class="language-plaintext highlighter-rouge">Query.rewrite()</code>)<li>그 뒤 쪼개진 각 쿼리를 수행시 얼마나 비용이 소모되는지 내부적으로 추정한다. 비용의 효과를 추정하고 유리할 것으로 생각되는 부분을 먼저 수행한다. (<code class="language-plaintext highlighter-rouge">DocIdSetIterator.cost()</code>)<li>bool 쿼리를 담당하는 BooleanWeight는 쿼리의 세부 내용에 따라 다양한 종류의 최적화된 Scorer를 만들어서 반환한다.</ul><h5 id="conjunction-검색과-docidsetiterator-순회"><span class="mr-2">conjunction 검색과 DocIdSetIterator 순회</span><a href="#conjunction-검색과-docidsetiterator-순회" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><ul><li>conjunction 검색은 AND 성격의 검색으로 주어진 쿼리의 매치 조건을 모두 만족해야 최종 매치된 것으로 판정한다.<li>disjunction 검색은 OR 성격의 검색으로 주어진 쿼리의 매치 조건 중 하나만 만족해도 최종 매치된 것으로 판단한다.<li>위 2가지 방식 모두 하위 Query마다 Weight에 이어 Scorer를 미리 만들어 둔 다음 하위 Scorer들을 가지고 최종 Scorer를 만든다.</ul><p><a href="https://github.com/sungsu9022/study/assets/6982740/1bdb445b-201c-422c-92a8-a5191d6ff947" class="popup img-link "><img width="473" alt="스크린샷 2024-02-04 오후 7 49 00" data-src="https://github.com/sungsu9022/study/assets/6982740/1bdb445b-201c-422c-92a8-a5191d6ff947" class="lazyload" data-proofer-ignore></a></p><ul><li>conjunction 방식에서는 각 항목에 대한 DocIdSetIterator을 뽑고, cost순으로 정렬 한 뒤 제일 작은 cost를 가진 Iterator순으로 순회한다.<ul><li>첫번쨰 항목에 대한것을 수행하고, doc을 기준으로 다음것을 수행하여 두번쨰 항목에서도 가리키는지를 확인하고, 모든 항목에 대해서 같은 doc을 바라보는지 확인하여 모두 일치하다면 매치된것으로 판단한다.</ul></ul><h5 id="disjunction-검색과-건너-뛰기"><span class="mr-2">disjunction 검색과 건너 뛰기</span><a href="#disjunction-검색과-건너-뛰기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><ul><li>disjunction 검색도 하위 Scorer와 Iterator을 이용해 최상위 레벨의 Scorer와 Iterator를 생성한다.<li>OR 검색이므로 개념적으로 결과 중 최솟값을 반환한다.<li>구현은 하위 Iterator를 현재 doc ID를 기준으로 하는 최소 힙을 이용한다.<li>유사도 점수를 계산해서 상위 k개의 문서를 수집하면 되는 상황이라면 현재까지 수집된 k번쨰 문서보다 점수 경쟁력이 떨어지는 문서나 문서의 블록을 적극적으로 건너띄는 여러 가지 최적화 방법을 함께 사용한다.</ul><h5 id="쿼리-문맥과-필터-문맥"><span class="mr-2">쿼리 문맥과 필터 문맥</span><a href="#쿼리-문맥과-필터-문맥" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><ul><li>쿼리 문맥의 쿼리든 필터 문맥의 쿼리든 수행 순서와는 관련이 없다.<li>DocIdSetIterator 인스턴스생성이 끝난 후에야 LeafCollector가 순회하며 데이터를 수집하고, 그 안에서 socre를 계산한다.<li>이러한 흐름 자체가 쿼리 문맥, 필터 문맥 상관 없이 하위 쿼리에 매치되는 후보군 자체를 일단 다 뽑는다는 것을 의미한다.<li>필터 문맥의 쿼리는 이때 score를 호출하여 점수를 계싼하는 비용을 아끼는것일뿐 먼저 수행되는것은 아니다.<li>매치되는 단일 문서마다 유사도 점수를 계산하며 수집한다는 것은 하위 쿼리의 동작 일부가 병렬적으로 수행된다는 것을 의미한다.</ul><h3 id="823-캐시-동작"><span class="mr-2">8.2.3 캐시 동작</span><a href="#823-캐시-동작" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>검색 성능이 아쉽다면 캐시를 잘 활용하고 있는지 검토해 볼 필요가 있다.</ul><h4 id="샤드-레벨-요청-캐시"><span class="mr-2">샤드 레벨 요청 캐시</span><a href="#샤드-레벨-요청-캐시" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>샤드 레벨 요청 캐시(request cache)는 검색 수행 시 query 페이즈에서 수행된 작업을 샤드 레벨에 저장하는 캐시이다.</ul><h5 id="캐시-수행-위치"><span class="mr-2">캐시 수행 위치</span><a href="#캐시-수행-위치" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><ul><li>SearchQueryThenFetchAsyncAction 작업 이후 QueryPhase 작업에 들어갈 떄 동작한다.<li>ShardSearchRequest와 대상 인덱스 설정을 보고 캐시 가능한 요청인지 여부를 파악한다.</ul><h5 id="캐시-조건"><span class="mr-2">캐시 조건</span><a href="#캐시-조건" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><ul><li>ES 검색 수행 시 요청 캐시를 활용하려면 다음 조건을 만족해야 한다.<ul><li>search_type이 query_then_fetch이어야 한다.<li>scroll 검색이 아니어야 한다.<li>profile 요청이 아니어야 한다. ( <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-profile.html">Profile API</a> )<ul><li>검색 요청의 개별 구성 요소 실행에 대한 자세한 타이밍 정보를 제공받기 위한 요청, 디버깅용</ul><li>now가 포함된 날짜 시간 계싼 표현이나 Math.random() 같은 명령이 포함된 스크립트가 아니어야 한다.<li>api 호출시 requestCache 매개변수를 명시적으로 지정한 경우 true이어야 한다.<li>매배견수를 지정하지 않는 경우 <code class="language-plaintext highlighter-rouge">index.requests.cache.enable</code> 인덱스 설정이 true여야 한다.(default : true)<li>검색 요청의 size 매배견수가 0이어야 캐시 대상이 될 수 있다.<ul><li>명시적으로 requestCache를 true로 지정하면 이 여부와 관계 없이 캐시를 수행한다.</ul></ul></ul><h5 id="캐시-키"><span class="mr-2">캐시 키</span><a href="#캐시-키" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><ul><li>요청이 캐시 대상이라는 사실을 확인하고 나면 캐시 키를 만든다.<li>인덱스, 샤드 번호와 검색 요청의 본문 내용 등 사실상 완전히 같은 검색 요청이어야 캐시가 적중되는 구조이다.<li>인가되지 않은 사용자가 캐시에 올라간 데이터를 받아가지 않게 하기 위한 추가적인 로직이 있음.</ul><h5 id="캐시-대상-값"><span class="mr-2">캐시 대상 값</span><a href="#캐시-대상-값" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><ul><li>캐시 키를 만든 후에는 이 키로 캐시에 올라간 데이터가 있는지 찾는다.<li>캐시가 적중했다면 쿼리 매치 작업을 수행하지 않고 캐시된 값을 바로 이용한다.<li>제안 결과, 집계 결과, 매치된 문서 수, 최대 점수, 매치된 상위 문서 등 모든 응답 값이 캐시된다.</ul><h5 id="샤드-레벨-요청-캐시-활용-방향"><span class="mr-2">샤드 레벨 요청 캐시 활용 방향</span><a href="#샤드-레벨-요청-캐시-활용-방향" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><ul><li>샤드 레벨 요청 캐시의 주 목적 자체가 size를 0으로 지정해 요청하는 집계 결과를 캐시하는 것이 목적이다.<li>매치된 상위 문서가 무엇인지, 유사도 점수가 얼마인지는 캐시에서 가져올 수 있지만, 그 문서의 <code class="language-plaintext highlighter-rouge">_source</code>는 FetchPhase를 통해서 가져와야 한다. 그러므로 집계를 지정하지 않은 일반적인 검색 요청의 쿼리 매치 작업 결과를 캐시하는 것은 집계 작업을 캐시하는 것보다 효율성이 떨어진다.(기본 동작이 size = 0 인 요청하는 캐시하는 이유)<li>서비스 특성상 ES 클러스터의 주 사용 용도가 집계가 아닌 일반 검색이고, 동일한 쿼리가 여러 번 인입될 가능성이 있다면 요청 캐시를 적극적으로 사용하는 것도 좋다.<ul><li>이 경우 requestCache 매개변수를 true로 지정해서 요청하는 방식을 사용하자.<li>FetchPhase은 무조건 수행해야 하기는 하지만, QueryPhase의 작업을 생략할 수 있는 것만으로도 성능 차이가 클 수 있다.</ul></ul><h5 id="캐시가-적재되는-위치"><span class="mr-2">캐시가 적재되는 위치</span><a href="#캐시가-적재되는-위치" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><ul><li>ES 노드가 기동하는 과정에서 Node 클래스, IndicesService 인스턴스가 생성되고, 이 내부의 IndicesRequestCahe 인스턴스를 멤버로 관리하며 실제 Cache는 여기서 관리된다.<li>즉 샤드 레벨 요청 캐시는 노드와 생명주기를 같이 한다고 보면 된다.</ul><h5 id="캐시-상태-확인"><span class="mr-2">캐시 상태 확인</span><a href="#캐시-상태-확인" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>GET /_status/request_cache/human
</pre></table></code></div></div><ul><li>위와 같이 인덱스별 혹은 전체 인덱스의 캐시 적중, 부적중, 퇴거(eviction) 회수, 캐시 크기 등의 주요 정보를 확인 할수 있다.</ul><h5 id="캐시-크기-지정과-캐시-무효화"><span class="mr-2">캐시 크기 지정과 캐시 무효화</span><a href="#캐시-크기-지정과-캐시-무효화" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><ul><li>기본 설정으로는 총 힙의 1%까지 샤드 레벨 요청 캐시로 사용한다.<li><code class="language-plaintext highlighter-rouge">config/elasticsearch.yml</code>의 <code class="language-plaintext highlighter-rouge">indices.requests.cache.size</code>을 변경하고 재기동하여 이 값을 변경할 수 있다.<ul><li>ex. <code class="language-plaintext highlighter-rouge">indices.requests.cache.size:2%</code></ul><li>샤드 레벨 요청 캐시는 인덱스 refresh를 수행할 때마다 무효화된다. 수동으로 무효화하려면 아래 API를 호출할 수 있다.<ul><li><code class="language-plaintext highlighter-rouge">POST [인덱스 이름]/_cache/clear?request=true</code></ul></ul><h4 id="노드-레벨-캐시"><span class="mr-2">노드 레벨 캐시</span><a href="#노드-레벨-캐시" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>노드 레벨 캐시는 필터 문맥으로 검색 수행시 쿼리에 어떤 문서가 매치됐는지를 노드 레벨에 저장하는 캐시이다.</ul><h5 id="캐시-수행-위치-1"><span class="mr-2">캐시 수행 위치</span><a href="#캐시-수행-위치-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><ul><li>QueryPhase에서 검색 수행 시 <code class="language-plaintext highlighter-rouge">IndexSearcher.search()</code>을 수행하고, 여기서 유사도 점수를 계산하지 않는 쿼리라면 쿼리 캐시를 적용하는 CachingWeightWrapper로 감싸 최종 Wieght를 반환하고, 검색을 수행하는 과정에서 캐시된 DocIdSet을 순회하는 Iterator을 반환한다.</ul><h5 id="캐시-대상-값-1"><span class="mr-2">캐시 대상 값</span><a href="#캐시-대상-값-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><ul><li>캐시에 적재하는 값인 DocIdSet 추상 클래스는 쿼리에 매치된 문서 목록을 나타낸다.<li>여러 DocIdSet의 구현체가 있지만, 비트 배열로 구현한다. (ex. 4번 문서가 매치된 경우 배열의 비트를 1로 처리한다.</ul><h5 id="캐시-키-1"><span class="mr-2">캐시 키</span><a href="#캐시-키-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><ul><li>캐시의 키는 Query이다. Query의 equals와 hashCode 구현상 같은 Query로 취급되는 경우 캐시를 적중시킬 수 있다.</ul><h5 id="bool-쿼리에서-노드-레벨-쿼리-캐시-활용"><span class="mr-2">bool 쿼리에서 노드 레벨 쿼리 캐시 활용</span><a href="#bool-쿼리에서-노드-레벨-쿼리-캐시-활용" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><ul><li>쿼리 문맥과 필터 문맥을 모두 가지고 있는 bool 쿼리는 쿼리 중 일 부분인 필터 문맥 부분만 잘 분리하여 캐시한다.<ul><li>여러 bool 쿼리의 내용을 바꿔가며 수행하더라도 필터 문맥의 하위 쿼리 중 일부가 겹친다면 부분적으로 캐시의 혜택을 볼 수 있다.<li>쿼리 문맥은 노드 레벨 쿼리 캐시가 안된다고 보면 된다.</ul></ul><h5 id="캐시-조건-1"><span class="mr-2">캐시 조건</span><a href="#캐시-조건-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><ul><li>캐시를 활용하기 위해서는 유사도 점수를 계산하지 않는 쿼리여야 한다는 점 외에도 조건이 많다.<li>1만개 이상의 문서가 있으며 동시에 샤드 내 문사ㅓ의 3% 이상을 보유하고 있는 세그먼트가 대상일 떄만 캐시한다.<ul><li>내부 테스트 목적으로 설정의 해당 조건을 아예 제거할수는 있지만, 1만과 3%의 숫자 값은 바꿀 수 없다.</ul><li>이 외에도 쿼리 캐시 없이도 충분히 빠르다고 판단하는 쿼리는 캐시하지 않는다.<li>최근 해당 쿼리를 얼마나 수행했는지 이력을 추적하여 루씬 내부적인 기준으로 무겁다고 판단한 쿼리는 2회 이상, 그 외는 4~5회 이상 반복 수행해야만 캐시를 수행한다.</ul><h5 id="락-획득"><span class="mr-2">락 획득</span><a href="#락-획득" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><ul><li>노드 레벨 쿼리 캐시는 읽기 작업과 쓰기 작업에 모두 락 획득을 필요로 한다.<li>읽기 작업 도중 락 획득은 무작정 기다리지는 않고, 락 획득 시도가 실패하면 바로 일반 검색 작업을 진행한다.</ul><h5 id="쿼리-캐시-상태-확인"><span class="mr-2">쿼리 캐시 상태 확인</span><a href="#쿼리-캐시-상태-확인" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>GET /_stats/query/_cache?human
</pre></table></code></div></div><ul><li>이 요청을 통해 인덱스별 혹은 전체 인덱스의 캐시 적중, 부적중, 퇴거 회수, 캐시 크기 등 주요 노드 레벨 쿼리 캐시의 상태를 확인할 수 있다.</ul><h5 id="캐시-크기-지정"><span class="mr-2">캐시 크기 지정</span><a href="#캐시-크기-지정" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><ul><li>기본 설정으로는 총 힙의 10%까지 노드 레벨 쿼리 캐시를 사용한다.<li><code class="language-plaintext highlighter-rouge">config/elasticsearch.yml</code>의 <code class="language-plaintext highlighter-rouge">indics.queries.cache.size: 5%</code> 와 같이 지정해서 값을 변경할 수 있다.</ul><h6 id="쿼리-캐시-무효화">쿼리 캐시 무효화</h6><ul><li>쿼리 캐시도 인덱스 refresh를 수행할떄 캐시가 무효화되고, 수동으로 무효화 하는 경우 아래 API를 호출할 수 있다.<ul><li>파라미터가 <code class="language-plaintext highlighter-rouge">request / query</code> 로 구분해서 달리 처리할 수 있다.</ul></ul><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>POST [인덱스 이름]/_cache/clear?query=true
</pre></table></code></div></div><h4 id="es의-캐시-적재-위치-구성"><span class="mr-2">ES의 캐시 적재 위치 구성</span><a href="#es의-캐시-적재-위치-구성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><a href="https://github.com/sungsu9022/study/assets/6982740/47a7bfee-f094-46be-9cbb-c86e3f73c478" class="popup img-link "><img width="480" alt="스크린샷 2024-02-04 오후 8 33 53" data-src="https://github.com/sungsu9022/study/assets/6982740/47a7bfee-f094-46be-9cbb-c86e3f73c478" class="lazyload" data-proofer-ignore></a></p><h5 id="샤드-레벨-요청-캐시와-노드-레벨-캐시-비교"><span class="mr-2">샤드 레벨 요청 캐시와 노드 레벨 캐시 비교</span><a href="#샤드-레벨-요청-캐시와-노드-레벨-캐시-비교" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><div class="table-wrapper"><table><thead><tr><th> <th>요청 캐시<th>쿼리 캐시<tbody><tr><td>수행 위치<td>QueryPhase 작업 들어가기 직전<td>래핑한 Weight에서 BulkScorer, Scorer 등 생성시<tr><td>키<td>SharedSearchRequest<td>Query<tr><td>값<td>매치된 상위 문서와 점수의 목록, 제안, 집계 등을 포함한 QueryPhase의 수행 결과<td>매치된 문서 목록을 나타내는 비트 배열<tr><td>주요 캐시 조건<td>1. 요청에 requestCache를 명시적으로 지정, 2. index.requests.cache.enabled=true &amp;&amp; size가 0인 집계 쿼리, 그 외 확정적인 검색 등 기본 조건<td>필터 문맥에서 쿼리를 많이 자주 수행해야 하고, 빠른 쿼리는 제외되며 세그먼트에 일정 이상의 문서가 있는 경우<tr><td>적재 위치<td>IndicesService.IndicesRequestCache<td>IndicesService.IndicesQueryCache<tr><td>캐시 접근 범위<td>샤드 레벨<td>노드 레벨</table></div><h5 id="운영체제-레벨-페이지-캐시"><span class="mr-2">운영체제 레벨 페이지 캐시</span><a href="#운영체제-레벨-페이지-캐시" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><ul><li>위 캐시 외에 OS 레벨에서 기본적으로 동작하는 페이지 캐시가 있다.<li>OS는 디스크에서 데이터를 읽은 후 데이터를 메모리에 넣어 두었다가 다시 이 데이터를 읽을 일이 있으면 디스크가 아니라 메모리에서 읽어 반환한다.<li>ES는 페이지 캐시를 잘 활용하고 있으므로 시스템 메모리의 절반 이상은 캐시로 사용하도록 설정하는 것이 좋다.</ul><h2 id="refernece"><span class="mr-2">Refernece</span><a href="#refernece" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><a href="https://velog.io/@khj2872/Elasticsearch-preference-query-parameter">preference 관련 트래블슈팅 사례</a><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/collapse-search-results.html">collapse를 이용한 검색 축소</a><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-profile.html">Profile API</a></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/devlog/'>DevLog</a>, <a href='/categories/elasticsearch/'>Elasticsearch</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/elasticsearch/" class="post-tag no-text-decoration" >Elasticsearch</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=[%EC%97%98%EB%9D%BC%EC%8A%A4%ED%8B%B1%EC%84%9C%EC%B9%98%20%EB%B0%94%EC%9D%B4%EB%B8%94]%208.%20%EC%97%98%EB%9D%BC%EC%8A%A4%ED%8B%B1%EC%84%9C%EC%B9%98%EC%9D%98%20%EB%82%B4%EB%B6%80%20%EB%8F%99%EC%9E%91%20%EC%83%81%EC%84%B8%20-%20Sungsu's%20Tech%20Blog&url=https%3A%2F%2Fsungsu9022.github.io%2Fposts%2Fes-bible-8%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=[%EC%97%98%EB%9D%BC%EC%8A%A4%ED%8B%B1%EC%84%9C%EC%B9%98%20%EB%B0%94%EC%9D%B4%EB%B8%94]%208.%20%EC%97%98%EB%9D%BC%EC%8A%A4%ED%8B%B1%EC%84%9C%EC%B9%98%EC%9D%98%20%EB%82%B4%EB%B6%80%20%EB%8F%99%EC%9E%91%20%EC%83%81%EC%84%B8%20-%20Sungsu's%20Tech%20Blog&u=https%3A%2F%2Fsungsu9022.github.io%2Fposts%2Fes-bible-8%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fsungsu9022.github.io%2Fposts%2Fes-bible-8%2F&text=[%EC%97%98%EB%9D%BC%EC%8A%A4%ED%8B%B1%EC%84%9C%EC%B9%98%20%EB%B0%94%EC%9D%B4%EB%B8%94]%208.%20%EC%97%98%EB%9D%BC%EC%8A%A4%ED%8B%B1%EC%84%9C%EC%B9%98%EC%9D%98%20%EB%82%B4%EB%B6%80%20%EB%8F%99%EC%9E%91%20%EC%83%81%EC%84%B8%20-%20Sungsu's%20Tech%20Blog" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/es-bible-4-3/">[엘라스틱서치 바이블] 4. 데이터 다루기 -3(ES Client 라이브러리)</a><li><a href="/posts/es-bible-4-2/">[엘라스틱서치 바이블] 4. 데이터 다루기 -2(집계)</a><li><a href="/posts/es-bible-2/">[엘라스틱서치 바이블] 2. 엘라스틱 서치 기본 동작과 구조</a><li><a href="/posts/es-bible-3-1/">[엘라스틱서치 바이블] 3. 인덱스 설계 - 1</a><li><a href="/posts/spark-guide-6/">[스파크 완벽 가이드] 6. 다양한 데이터 타입 다루기</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/spark/">Spark</a> <a class="post-tag" href="/tags/infra/">Infra</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/kubernetes-in-action/">kubernetes-in-action</a> <a class="post-tag" href="/tags/kubernetes/">kubernetes</a> <a class="post-tag" href="/tags/elasticsearch/">Elasticsearch</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/effective-java/">Effective Java</a> <a class="post-tag" href="/tags/hands-on-reactive-programming-in-spring-5/">Hands-On Reactive Programming in Spring 5</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/es-bible-1/"><div class="card-body"> <em class="small" data-ts="1700127840" data-df="ll" > Nov 16, 2023 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[엘라스틱서치 바이블] 1. 엘라스틱 서치 소개</h3><div class="text-muted small"><p> 1. 엘라스틱 서치 소개 Elasticsearch는 2010년 2월 샤이 베논이 아파치의 루씬 라이브러리를 기반으로 만든 분산 검색 엔진 2013년에 데이터를 손쉽게 시각화하는 Kibana와 색인 데이터 수집&amp;amp;변환을 하는 Logstash 프로젝트에 엘라스틱에 합류 엘라스틱서치는 현재 검색 엔진 분야에서 가장 각광받고 있는 시스템이다...</p></div></div></a></div><div class="card"> <a href="/posts/es-bible-2/"><div class="card-body"> <em class="small" data-ts="1700218920" data-df="ll" > Nov 17, 2023 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[엘라스틱서치 바이블] 2. 엘라스틱 서치 기본 동작과 구조</h3><div class="text-muted small"><p> 2. 엘라스틱 서치 기본 동작과 구조 엘라스틱서치의 구조를 어느정도 먼저 이해한 상태에서 상세 내용을 학습해야 전체 학습에 깊이가 생긴다. 이번 장을 마치고 나면 엘라스틱서치가 어떻게 동작하는지 큰 그림을 머릿속에 그릴수 있을것이다. 2.1 엘라스틱서치 기본 동작 빠르게 둘러보기 실습 과정에서는 기본적으로 REST API를 호출해 진...</p></div></div></a></div><div class="card"> <a href="/posts/es-bible-3-1/"><div class="card-body"> <em class="small" data-ts="1700301000" data-df="ll" > Nov 18, 2023 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[엘라스틱서치 바이블] 3. 인덱스 설계 - 1</h3><div class="text-muted small"><p> 3. 인덱스 설계 - 1 ES의 인덱스는 아주 세부적인 부분까지 설정으로 제어할 수 있다. 이 설정에 따라 동작과 특성이 매우 달라지므로 인덱스 설계에 신경써야 한다. 맵핑, 필드 타입, 애널라이저 등 핵심적인 설정을 학습해 ES 인덱스에 대한 이해도를 높여보자. 3.1 인덱스 설정 인덱스 생성시 동작에 관한 설정을 지정할 수 있...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/es-bible-5/" class="btn btn-outline-primary" prompt="Older"><p>[엘라스틱서치 바이블] 5. 서비스 환경에 클러스터 구성</p></a> <a href="/posts/devlog-spring6-http-clients-1/" class="btn btn-outline-primary" prompt="Newer"><p>[Spring] Spring6 Http Interface Client - 1</p></a></div><div id="disqus_thread" class="pt-2 pb-2"><p class="text-center text-muted small">Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script type="text/javascript"> var disqus_config = function () { this.page.url = 'https://sungsu9022.github.io/posts/es-bible-8/'; this.page.identifier = '/posts/es-bible-8/'; }; /* Lazy loading */ var disqus_observer = new IntersectionObserver( function (entries) { if (entries[0].isIntersecting) { (function () { var d = document, s = d.createElement('script'); s.src = 'https://sungsu-parks-tech-blog.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); disqus_observer.disconnect(); } }, { threshold: [0] } ); disqus_observer.observe(document.querySelector('#disqus_thread')); /* Auto switch theme */ function reloadDisqus() { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* Disqus hasn't been loaded */ if (typeof DISQUS === 'undefined') { return; } if (document.readyState == 'complete') { DISQUS.reset({ reload: true, config: disqus_config }); } } } if (document.querySelector('.mode-toggle')) { window.addEventListener('message', reloadDisqus); } </script></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/spark/">Spark</a> <a class="post-tag" href="/tags/infra/">Infra</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/kubernetes-in-action/">kubernetes-in-action</a> <a class="post-tag" href="/tags/kubernetes/">kubernetes</a> <a class="post-tag" href="/tags/elasticsearch/">Elasticsearch</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/effective-java/">Effective Java</a> <a class="post-tag" href="/tags/hands-on-reactive-programming-in-spring-5/">Hands-On Reactive Programming in Spring 5</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://twitter.com/sungsu9022dev">sungsu9022</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0">Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></div></footer><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-145894105-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-145894105-1'); }); </script>
